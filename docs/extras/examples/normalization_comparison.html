<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Normalization Methods for Geospatial Foundation Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/quarto-contrib/fontawesome6-1.2.0/all.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/fontawesome6-1.2.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">GEOG 288KC</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">🏠 home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../Syllabus.html"> 
<span class="menu-text">📋 syllabus</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-weekly-sessions" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">💻 weekly sessions</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-weekly-sessions">    
        <li>
    <a class="dropdown-item" href="../../chapters/c01-geospatial-data-foundations.html">
 <span class="dropdown-text">Week 1 - 🚀 Core Tools and Data Access</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c02-spatial-temporal-attention-mechanisms.html">
 <span class="dropdown-text">Week 2 - ⚡ Rapid Remote Sensing Preprocessing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c03a-terratorch-foundations.html">
 <span class="dropdown-text">Week 3a - 🌍 TerraTorch Foundations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c03-complete-gfm-architecture.html">
 <span class="dropdown-text">Week 3b - 🤖 Machine Learning on Remote Sensing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c04-pretraining-implementation.html">
 <span class="dropdown-text">Week 4 - 🏗️ Foundation Models in Practice</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c05-training-loop-optimization.html">
 <span class="dropdown-text">Week 5 - 🔧 Fine-Tuning &amp; Transfer Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c06-model-evaluation-analysis.html">
 <span class="dropdown-text">Week 6 - ⏰ Spatiotemporal Modeling &amp; Projects</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-cheatsheets" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">👀 cheatsheets</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-cheatsheets">    
        <li>
    <a class="dropdown-item" href="../../cheatsheets.html">
 <span class="dropdown-text">📋 All Cheatsheets</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">⚡ Quick Starts</li>
        <li>
    <a class="dropdown-item" href="../../extras/cheatsheets/week01_imports.html">
 <span class="dropdown-text">Week 01: Import Guide</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-explainers" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">🧩 explainers</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-explainers">    
        <li class="dropdown-header">1️⃣ Week 1</li>
        <li>
    <a class="dropdown-item" href="../../extras/ai-ml-dl-fm-hierarchy.html">
 <span class="dropdown-text">🤖 AI/ML/DL/FM Hierarchy</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/geospatial-foundation-model-predictions-standalone.html">
 <span class="dropdown-text">🎯 GFM Predictions (Standalone)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/geospatial-prediction-hierarchy.html">
 <span class="dropdown-text">✅ Geospatial Task/Prediction Types</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/neural_networks_explainer.html">
 <span class="dropdown-text">🧠 Neural Networks: Neurons to Transformers</span></a>
  </li>  
        <li class="dropdown-header">2️⃣ Week 2</li>
        <li>
    <a class="dropdown-item" href="../../chapters/c00a-foundation_model_architectures.html">
 <span class="dropdown-text">🏗️ Foundation Model Architectures</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c00b-introduction-to-deeplearning-architecture.html">
 <span class="dropdown-text">🎓 Introduction to Deep Learning Architecture</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-extras" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">📖 extras</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-extras">    
        <li class="dropdown-header">🎯 Practical Examples</li>
        <li>
    <a class="dropdown-item" href="../../extras/examples/normalization_comparison.html">
 <span class="dropdown-text">Normalization Comparison</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/examples/resnet.html">
 <span class="dropdown-text">ResNet Implementation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/examples/segmentation_finetuning.html">
 <span class="dropdown-text">Segmentation Fine-Tuning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/examples/text_encoder.html">
 <span class="dropdown-text">Text Encoder</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/examples/tiling-and-patches.html">
 <span class="dropdown-text">Tiling and Patches</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/examples/terratorch_workflows.html">
 <span class="dropdown-text">TerraTorch Workflows</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/resources/course_resources.html">
 <span class="dropdown-text">📚 Reference Materials</span></a>
  </li>  
        <li class="dropdown-header">📁 Project Templates</li>
        <li>
    <a class="dropdown-item" href="../../extras/projects/project-proposal-template.html">
 <span class="dropdown-text">Project Proposal Template</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/projects/mvp-template.html">
 <span class="dropdown-text">Project Results Template</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/gfms-from-scratch/gfms-from-scratch.github.io" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <div class="quarto-title-block"><div><h1 class="title">Normalization Methods for Geospatial Foundation Models</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
            <p class="subtitle lead">Comparing approaches used in state-of-the-art GFMs</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#learning-objectives" id="toc-learning-objectives" class="nav-link" data-scroll-target="#learning-objectives">Learning Objectives</a></li>
  <li><a href="#setting-up" id="toc-setting-up" class="nav-link" data-scroll-target="#setting-up">Setting Up</a></li>
  <li><a href="#normalization-algorithms-in-geospatial-foundation-models" id="toc-normalization-algorithms-in-geospatial-foundation-models" class="nav-link" data-scroll-target="#normalization-algorithms-in-geospatial-foundation-models">Normalization Algorithms in Geospatial Foundation Models</a>
  <ul class="collapse">
  <li><a href="#algorithm-1-min-max-normalization" id="toc-algorithm-1-min-max-normalization" class="nav-link" data-scroll-target="#algorithm-1-min-max-normalization">Algorithm 1: Min-Max Normalization</a></li>
  <li><a href="#algorithm-2-z-score-standardization" id="toc-algorithm-2-z-score-standardization" class="nav-link" data-scroll-target="#algorithm-2-z-score-standardization">Algorithm 2: Z-Score Standardization</a></li>
  <li><a href="#algorithm-3-robust-interquartile-range-iqr-scaling" id="toc-algorithm-3-robust-interquartile-range-iqr-scaling" class="nav-link" data-scroll-target="#algorithm-3-robust-interquartile-range-iqr-scaling">Algorithm 3: Robust Interquartile Range (IQR) Scaling</a></li>
  <li><a href="#algorithm-4-percentile-clipping" id="toc-algorithm-4-percentile-clipping" class="nav-link" data-scroll-target="#algorithm-4-percentile-clipping">Algorithm 4: Percentile Clipping</a></li>
  <li><a href="#algorithm-5-adaptive-hybrid-approach" id="toc-algorithm-5-adaptive-hybrid-approach" class="nav-link" data-scroll-target="#algorithm-5-adaptive-hybrid-approach">Algorithm 5: Adaptive Hybrid Approach</a></li>
  </ul></li>
  <li><a href="#load-and-examine-test-data" id="toc-load-and-examine-test-data" class="nav-link" data-scroll-target="#load-and-examine-test-data">Load and Examine Test Data</a></li>
  <li><a href="#raw-data-visualization" id="toc-raw-data-visualization" class="nav-link" data-scroll-target="#raw-data-visualization">Raw Data Visualization</a></li>
  <li><a href="#visual-comparison-how-each-method-transforms-spatial-data" id="toc-visual-comparison-how-each-method-transforms-spatial-data" class="nav-link" data-scroll-target="#visual-comparison-how-each-method-transforms-spatial-data">Visual Comparison: How Each Method Transforms Spatial Data</a></li>
  <li><a href="#performance-comparison" id="toc-performance-comparison" class="nav-link" data-scroll-target="#performance-comparison">Performance Comparison</a>
  <ul class="collapse">
  <li><a href="#computational-speed" id="toc-computational-speed" class="nav-link" data-scroll-target="#computational-speed">Computational Speed</a></li>
  <li><a href="#robustness-to-outliers" id="toc-robustness-to-outliers" class="nav-link" data-scroll-target="#robustness-to-outliers">Robustness to Outliers</a></li>
  <li><a href="#statistical-properties-comparison" id="toc-statistical-properties-comparison" class="nav-link" data-scroll-target="#statistical-properties-comparison">Statistical Properties Comparison</a></li>
  </ul></li>
  <li><a href="#recommendations-for-different-scenarios" id="toc-recommendations-for-different-scenarios" class="nav-link" data-scroll-target="#recommendations-for-different-scenarios">Recommendations for Different Scenarios</a>
  <ul class="collapse">
  <li><a href="#high-quality-single-sensor-data" id="toc-high-quality-single-sensor-data" class="nav-link" data-scroll-target="#high-quality-single-sensor-data">🏔️ High-Quality, Single-Sensor Data</a></li>
  <li><a href="#multi-sensor-cross-platform-applications" id="toc-multi-sensor-cross-platform-applications" class="nav-link" data-scroll-target="#multi-sensor-cross-platform-applications">🛰️ Multi-Sensor, Cross-Platform Applications</a></li>
  <li><a href="#noisy-data-with-atmospheric-contamination" id="toc-noisy-data-with-atmospheric-contamination" class="nav-link" data-scroll-target="#noisy-data-with-atmospheric-contamination">⛈️ Noisy Data with Atmospheric Contamination</a></li>
  <li><a href="#mixed-data-quality-general-purpose" id="toc-mixed-data-quality-general-purpose" class="nav-link" data-scroll-target="#mixed-data-quality-general-purpose">🌍 Mixed Data Quality (General Purpose)</a></li>
  <li><a href="#production-deployment-systems" id="toc-production-deployment-systems" class="nav-link" data-scroll-target="#production-deployment-systems">🚀 Production Deployment Systems</a></li>
  </ul></li>
  <li><a href="#key-takeaways" id="toc-key-takeaways" class="nav-link" data-scroll-target="#key-takeaways">Key Takeaways</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#resources" id="toc-resources" class="nav-link" data-scroll-target="#resources">Resources</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Different geospatial foundation models use various normalization strategies depending on their training data and objectives. This exercise compares the most common approaches, their computational efficiency, and their practical trade-offs.</p>
</section>
<section id="learning-objectives" class="level2">
<h2 class="anchored" data-anchor-id="learning-objectives">Learning Objectives</h2>
<ul>
<li>Compare normalization methods used in major GFMs (Prithvi, SatMAE, Clay)</li>
<li>Measure computational performance of different approaches</li>
<li>Understand when to use each method based on data characteristics</li>
<li>Implement robust normalization for multi-sensor datasets</li>
</ul>
</section>
<section id="setting-up" class="level2">
<h2 class="anchored" data-anchor-id="setting-up">Setting Up</h2>
<div id="be826bf0" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> urllib.request</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Set seeds for reproducibility</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Set up data path - use book/data for course sample data</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"__file__"</span> <span class="kw">in</span> <span class="bu">globals</span>():</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># From extras/examples, go up 2 levels to book folder, then to data</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    DATA_DIR <span class="op">=</span> Path(<span class="va">__file__</span>).parent.parent.parent <span class="op">/</span> <span class="st">"data"</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fallback for interactive environments - look for book folder</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> Path.cwd()</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> current.name <span class="kw">not</span> <span class="kw">in</span> [<span class="st">"book"</span>, <span class="st">"geoAI"</span>] <span class="kw">and</span> current.parent <span class="op">!=</span> current:</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> current.parent</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current.name <span class="op">==</span> <span class="st">"book"</span>:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        DATA_DIR <span class="op">=</span> current <span class="op">/</span> <span class="st">"data"</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> current.name <span class="op">==</span> <span class="st">"geoAI"</span>:</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        DATA_DIR <span class="op">=</span> current <span class="op">/</span> <span class="st">"book"</span> <span class="op">/</span> <span class="st">"data"</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        DATA_DIR <span class="op">=</span> Path(<span class="st">"data"</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>DATA_DIR.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>DATA_PATH <span class="op">=</span> DATA_DIR <span class="op">/</span> <span class="st">"landcover_sample.tif"</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> DATA_PATH.exists():</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">FileNotFoundError</span>(<span class="ss">f"Data file not found at </span><span class="sc">{</span>DATA_PATH<span class="sc">}</span><span class="ss">. Please ensure the landcover_sample.tif file is available in the data directory."</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Setup complete"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="normalization-algorithms-in-geospatial-foundation-models" class="level2">
<h2 class="anchored" data-anchor-id="normalization-algorithms-in-geospatial-foundation-models">Normalization Algorithms in Geospatial Foundation Models</h2>
<p>Different normalization strategies serve different purposes in geospatial machine learning. Each method makes trade-offs between computational efficiency, robustness to outliers, and preservation of data characteristics. Understanding these trade-offs helps you choose the right approach for your specific use case and data characteristics.</p>
<section id="algorithm-1-min-max-normalization" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-1-min-max-normalization">Algorithm 1: Min-Max Normalization</h3>
<p><strong>Used by:</strong> Early computer vision models, many baseline implementations<br>
<strong>Key characteristic:</strong> Linear scaling that preserves the original data distribution shape</p>
<p>Min-max normalization is the simplest scaling method, transforming data to a fixed range [0,1]. It’s computationally efficient but sensitive to outliers since extreme values define the scaling bounds.</p>
<p><strong>Mathematical formulation:</strong> For each band <span class="math inline">\(b\)</span> with spatial dimensions, let <span class="math inline">\(X_b \in \mathbb{R}^{H \times W}\)</span> be the input data. The normalized output is:</p>
<p><span class="math display">\[\hat{X}_b = \frac{X_b - \min(X_b)}{\max(X_b) - \min(X_b)}\]</span></p>
<p>where <span class="math inline">\(\min(X_b)\)</span> and <span class="math inline">\(\max(X_b)\)</span> are the minimum and maximum values across all spatial locations in band <span class="math inline">\(b\)</span>.</p>
<p><strong>Advantages:</strong> Fast computation, preserves data distribution shape, interpretable output range<br>
<strong>Disadvantages:</strong> Sensitive to outliers, can compress most data into narrow range if extreme values present</p>
<div id="46579b94" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_max_normalize(data, epsilon<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Min-max normalization: scales data to [0,1] range</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">    data : numpy.ndarray</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">        Input data with shape (bands, height, width)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">    epsilon : float</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">        Small value to prevent division by zero</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">    numpy.ndarray</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">        Normalized data with same shape as input</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    data_flat <span class="op">=</span> data.reshape(data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    mins <span class="op">=</span> data_flat.<span class="bu">min</span>(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    maxs <span class="op">=</span> data_flat.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> maxs <span class="op">-</span> mins</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Avoid division by zero for constant bands</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> np.maximum(ranges, epsilon)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (data <span class="op">-</span> mins.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">/</span> ranges.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the function with random data</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> np.random.randint(<span class="dv">50</span>, <span class="dv">200</span>, (<span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">10</span>)).astype(np.float32)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>test_result <span class="op">=</span> min_max_normalize(test_data)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Min-max result range: [</span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.3f}</span><span class="ss">]"</span>)</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output shape: </span><span class="sc">{</span>test_result<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="algorithm-2-z-score-standardization" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-2-z-score-standardization">Algorithm 2: Z-Score Standardization</h3>
<p><strong>Used by:</strong> Prithvi (NASA/IBM), many deep learning models for cross-platform compatibility<br>
<strong>Key characteristic:</strong> Centers data at zero with unit variance, enabling cross-sensor comparisons</p>
<p>Z-score standardization transforms data to have zero mean and unit variance. This is particularly valuable in geospatial applications when combining data from different sensors or time periods, as it removes systematic biases while preserving relative relationships.</p>
<p><strong>Mathematical formulation:</strong> For each band <span class="math inline">\(b\)</span>, the z-score normalized output is:</p>
<p><span class="math display">\[\hat{X}_b = \frac{X_b - \mu_b}{\sigma_b}\]</span></p>
<p>where <span class="math inline">\(\mu_b = \mathbb{E}[X_b]\)</span> is the mean and <span class="math inline">\(\sigma_b = \sqrt{\text{Var}[X_b]}\)</span> is the standard deviation of band <span class="math inline">\(b\)</span>.</p>
<p><strong>Advantages:</strong> Removes sensor biases, enables transfer learning, standard statistical interpretation<br>
<strong>Disadvantages:</strong> Can amplify noise in low-variance regions, unbounded output range</p>
<div id="815af0c6" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> z_score_normalize(data, epsilon<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Z-score standardization: transforms to zero mean, unit variance</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    data : numpy.ndarray</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">        Input data with shape (bands, height, width)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">    epsilon : float</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">        Small value to prevent division by zero</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co">    numpy.ndarray</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co">        Normalized data with mean≈0, std≈1 for each band</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    data_flat <span class="op">=</span> data.reshape(data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    means <span class="op">=</span> data_flat.mean(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    stds <span class="op">=</span> data_flat.std(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    stds <span class="op">=</span> np.maximum(stds, epsilon)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (data <span class="op">-</span> means.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">/</span> stds.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the function with random data</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> np.random.randint(<span class="dv">100</span>, <span class="dv">300</span>, (<span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">10</span>)).astype(np.float32)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>test_result <span class="op">=</span> z_score_normalize(test_data)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Z-score result mean: </span><span class="sc">{</span>test_result<span class="sc">.</span>mean()<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Z-score result std: </span><span class="sc">{</span>test_result<span class="sc">.</span>std()<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output range: [</span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.3f}</span><span class="ss">]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="algorithm-3-robust-interquartile-range-iqr-scaling" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-3-robust-interquartile-range-iqr-scaling">Algorithm 3: Robust Interquartile Range (IQR) Scaling</h3>
<p><strong>Used by:</strong> SatMAE, models handling noisy satellite data<br>
<strong>Key characteristic:</strong> Uses median and interquartile range instead of mean/std for outlier resistance</p>
<p>Robust scaling addresses the main weakness of z-score normalization: sensitivity to outliers. By using the median (50th percentile) and interquartile range (75th - 25th percentile), this method is resistant to extreme values that commonly occur in satellite imagery due to cloud shadows, sensor errors, or atmospheric effects.</p>
<p><strong>Mathematical formulation:</strong> For each band <span class="math inline">\(b\)</span>, the robust normalized output is:</p>
<p><span class="math display">\[\hat{X}_b = \frac{X_b - Q_{50}(X_b)}{Q_{75}(X_b) - Q_{25}(X_b)}\]</span></p>
<p>where <span class="math inline">\(Q_p(X_b)\)</span> denotes the <span class="math inline">\(p\)</span>-th percentile of band <span class="math inline">\(b\)</span>, and the denominator is the interquartile range (IQR).</p>
<p><strong>Advantages:</strong> Highly resistant to outliers, stable with contaminated data, preserves most data relationships<br>
<strong>Disadvantages:</strong> Slightly more computationally expensive, can underestimate true data spread</p>
<div id="12d5a47e" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> robust_iqr_normalize(data, epsilon<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Robust scaling using interquartile range (IQR)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Uses median instead of mean and IQR instead of standard deviation</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">    for resistance to outliers and extreme values.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">    data : numpy.ndarray</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Input data with shape (bands, height, width)</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">    epsilon : float</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">        Small value to prevent division by zero</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co">    numpy.ndarray</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co">        Robustly normalized data</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    data_flat <span class="op">=</span> data.reshape(data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    medians <span class="op">=</span> np.median(data_flat, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    q25 <span class="op">=</span> np.percentile(data_flat, <span class="dv">25</span>, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    q75 <span class="op">=</span> np.percentile(data_flat, <span class="dv">75</span>, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    iqr <span class="op">=</span> q75 <span class="op">-</span> q25</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    iqr <span class="op">=</span> np.maximum(iqr, epsilon)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (data <span class="op">-</span> medians.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">/</span> iqr.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the function with data containing outliers</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> np.random.randint(<span class="dv">80</span>, <span class="dv">120</span>, (<span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">10</span>)).astype(np.float32)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>test_data[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">500</span>  <span class="co"># Add an outlier</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>test_result <span class="op">=</span> robust_iqr_normalize(test_data)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Robust IQR result - median: </span><span class="sc">{</span>np<span class="sc">.</span>median(test_result)<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Robust IQR range: [</span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.3f}</span><span class="ss">]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="algorithm-4-percentile-clipping" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-4-percentile-clipping">Algorithm 4: Percentile Clipping</h3>
<p><strong>Used by:</strong> Scale-MAE, FoundationPose, many modern vision transformers<br>
<strong>Key characteristic:</strong> Clips extreme values before normalization, balancing robustness with data preservation</p>
<p>Percentile clipping combines outlier handling with normalization by first clipping values to a specified percentile range (typically 2nd-98th percentile), then scaling to [0,1]. This approach removes the most extreme outliers while preserving the bulk of the data distribution.</p>
<p><strong>Mathematical formulation:</strong> For each band <span class="math inline">\(b\)</span>, first clip the data:</p>
<p><span class="math display">\[X_b^{\text{clipped}} = \text{clip}(X_b, Q_{\alpha}(X_b), Q_{100-\alpha}(X_b))\]</span></p>
<p>Then apply min-max scaling:</p>
<p><span class="math display">\[\hat{X}_b = \frac{X_b^{\text{clipped}} - Q_{\alpha}(X_b)}{Q_{100-\alpha}(X_b) - Q_{\alpha}(X_b)}\]</span></p>
<p>where <span class="math inline">\(\alpha\)</span> is typically 2, giving the 2nd and 98th percentiles as clipping bounds.</p>
<p><strong>Advantages:</strong> Good balance of robustness and data preservation, bounded output, handles diverse data quality<br>
<strong>Disadvantages:</strong> Loss of extreme values that might be scientifically meaningful, requires percentile parameter tuning</p>
<div id="a64554ff" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> percentile_clip_normalize(data, p_low<span class="op">=</span><span class="dv">2</span>, p_high<span class="op">=</span><span class="dv">98</span>, epsilon<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Percentile-based normalization with clipping</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Clips data to specified percentile range, then normalizes to [0,1].</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Commonly used approach in modern vision transformers for satellite data.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">    data : numpy.ndarray</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Input data with shape (bands, height, width)</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">    p_low : float</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co">        Lower percentile for clipping (default: 2nd percentile)</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co">    p_high : float  </span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">        Upper percentile for clipping (default: 98th percentile)</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co">    epsilon : float</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Small value to prevent division by zero</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co">    numpy.ndarray</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="co">        Clipped and normalized data in [0,1] range</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    data_flat <span class="op">=</span> data.reshape(data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    p_low_vals <span class="op">=</span> np.percentile(data_flat, p_low, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    p_high_vals <span class="op">=</span> np.percentile(data_flat, p_high, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> p_high_vals <span class="op">-</span> p_low_vals</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> np.maximum(ranges, epsilon)</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Clip to percentile range, then normalize</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    clipped <span class="op">=</span> np.clip(data, p_low_vals.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>), p_high_vals.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (clipped <span class="op">-</span> p_low_vals.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">/</span> ranges.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the function with data containing outliers</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> np.random.randint(<span class="dv">60</span>, <span class="dv">140</span>, (<span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">10</span>)).astype(np.float32)</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>test_data[<span class="dv">0</span>, <span class="dv">0</span>:<span class="dv">2</span>, <span class="dv">0</span>:<span class="dv">2</span>] <span class="op">=</span> <span class="dv">1000</span>  <span class="co"># Add some outliers</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>test_result <span class="op">=</span> percentile_clip_normalize(test_data)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Percentile clip result range: [</span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.3f}</span><span class="ss">]"</span>)</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Data clipped to [0,1] range successfully"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="algorithm-5-adaptive-hybrid-approach" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-5-adaptive-hybrid-approach">Algorithm 5: Adaptive Hybrid Approach</h3>
<p><strong>Used by:</strong> Clay v1, production systems handling diverse data sources<br>
<strong>Key characteristic:</strong> Automatically selects normalization method based on data characteristics</p>
<p>The adaptive approach recognizes that no single normalization method works optimally for all data conditions. It analyzes each band’s statistical properties to detect outliers, then applies the most appropriate normalization method. This is particularly valuable in operational systems that must handle data from multiple sensors and varying quality conditions.</p>
<p><strong>Mathematical formulation:</strong> For each band <span class="math inline">\(b\)</span>, compute outlier ratio:</p>
<p><span class="math display">\[r_{\text{outlier}} = \frac{1}{HW}\sum_{i,j} \mathbb{I}(|z_{i,j}| &gt; \tau)\]</span></p>
<p>where <span class="math inline">\(z_{i,j} = \frac{X_{b,i,j} - \mu_b}{\sigma_b}\)</span> and <span class="math inline">\(\mathbb{I}\)</span> is the indicator function, <span class="math inline">\(\tau\)</span> is the outlier threshold.</p>
<p>Then apply: <span class="math display">\[
\hat{X}_b =
\begin{cases}
\text{RobustIQR}(X_b), &amp; \text{if } r_{\text{outlier}} &gt; 0.05 \\
\text{MinMax}(X_b), &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p><strong>Advantages:</strong> Adapts to data quality, robust across diverse inputs, maintains efficiency when possible<br>
<strong>Disadvantages:</strong> More complex implementation, slight computational overhead for outlier detection</p>
<div id="b0f68230" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> adaptive_hybrid_normalize(data, outlier_threshold<span class="op">=</span><span class="fl">3.0</span>, epsilon<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Adaptive normalization that selects method based on data characteristics</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Detects outliers in each band and applies robust or standard normalization</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">    accordingly. Useful for production systems handling diverse data quality.</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">    data : numpy.ndarray</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Input data with shape (bands, height, width)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">    outlier_threshold : float</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co">        Z-score threshold for outlier detection (default: 3.0)</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="co">    epsilon : float</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co">        Small value to prevent division by zero</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co">    numpy.ndarray</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co">        Adaptively normalized data</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    data_flat <span class="op">=</span> data.reshape(data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> band_idx <span class="kw">in</span> <span class="bu">range</span>(data.shape[<span class="dv">0</span>]):</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        band_data <span class="op">=</span> data[band_idx]</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        band_flat <span class="op">=</span> data_flat[band_idx]</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Detect outliers using z-score  </span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        z_scores <span class="op">=</span> np.<span class="bu">abs</span>((band_flat <span class="op">-</span> band_flat.mean()) <span class="op">/</span> (band_flat.std() <span class="op">+</span> epsilon))</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        outlier_ratio <span class="op">=</span> (z_scores <span class="op">&gt;</span> outlier_threshold).mean()</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> outlier_ratio <span class="op">&gt;</span> <span class="fl">0.05</span>:  <span class="co"># More than 5% outliers</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use robust method</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> robust_iqr_normalize(band_data[<span class="va">None</span>, :, :], epsilon)[<span class="dv">0</span>]</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use standard min-max</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> min_max_normalize(band_data[<span class="va">None</span>, :, :], epsilon)[<span class="dv">0</span>]</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>        results.append(result)</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.stack(results, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the function with mixed data quality</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> np.random.randint(<span class="dv">70</span>, <span class="dv">130</span>, (<span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">10</span>)).astype(np.float32)</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>test_data[<span class="dv">1</span>, :<span class="dv">3</span>, :<span class="dv">3</span>] <span class="op">=</span> <span class="dv">800</span>  <span class="co"># Add outliers to second band only</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>test_result <span class="op">=</span> adaptive_hybrid_normalize(test_data)</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Adaptive result range: [</span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.3f}</span><span class="ss">]"</span>)</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Method automatically adapts normalization based on data characteristics"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="load-and-examine-test-data" class="level2">
<h2 class="anchored" data-anchor-id="load-and-examine-test-data">Load and Examine Test Data</h2>
<div id="efbce0f3" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio <span class="im">as</span> rio</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Load our test image</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> rio.<span class="bu">open</span>(DATA_PATH) <span class="im">as</span> src:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">=</span> src.read().astype(np.float32)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Test data shape: </span><span class="sc">{</span>arr<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Data type: </span><span class="sc">{</span>arr<span class="sc">.</span>dtype<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Add some synthetic outliers to test robustness</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>arr_with_outliers <span class="op">=</span> arr.copy()</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Add more extreme values to better demonstrate robustness differences</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>original_max <span class="op">=</span> arr_with_outliers.<span class="bu">max</span>()</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>original_min <span class="op">=</span> arr_with_outliers.<span class="bu">min</span>()</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate various sensor failures with extreme values</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>arr_with_outliers[<span class="dv">0</span>, <span class="dv">10</span>:<span class="dv">15</span>, <span class="dv">10</span>:<span class="dv">15</span>] <span class="op">=</span> original_max <span class="op">*</span> <span class="dv">20</span>  <span class="co"># Severe hot pixels</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>arr_with_outliers[<span class="dv">1</span>, <span class="dv">20</span>:<span class="dv">25</span>, <span class="dv">20</span>:<span class="dv">25</span>] <span class="op">=</span> <span class="op">-</span>original_max <span class="op">*</span> <span class="dv">5</span>  <span class="co"># Negative artifacts (sensor errors)</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>arr_with_outliers[<span class="dv">2</span>, <span class="dv">5</span>:<span class="dv">10</span>, <span class="dv">30</span>:<span class="dv">35</span>] <span class="op">=</span> original_max <span class="op">*</span> <span class="dv">50</span>   <span class="co"># Extreme positive outliers</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>arr_with_outliers[<span class="dv">0</span>, <span class="dv">40</span>:<span class="dv">42</span>, <span class="dv">40</span>:<span class="dv">42</span>] <span class="op">=</span> original_min <span class="op">-</span> original_max <span class="op">*</span> <span class="dv">3</span>  <span class="co"># Extreme negative outliers</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Original value ranges:"</span>)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, band <span class="kw">in</span> <span class="bu">enumerate</span>(arr):</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>band<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.1f}</span><span class="ss"> to </span><span class="sc">{</span>band<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.1f}</span><span class="ss">"</span>)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">With synthetic outliers:"</span>)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, band <span class="kw">in</span> <span class="bu">enumerate</span>(arr_with_outliers):</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>band<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.1f}</span><span class="ss"> to </span><span class="sc">{</span>band<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.1f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="raw-data-visualization" class="level2">
<h2 class="anchored" data-anchor-id="raw-data-visualization">Raw Data Visualization</h2>
<p>Before comparing normalization methods, let’s examine our test datasets to understand what we’re working with. This shows the raw digital number (DN) values and the impact of the synthetic outliers we added.</p>
<div id="a4b80759" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the original data before normalization</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">10</span>))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean data - first band</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">0</span>].imshow(arr[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Clean Data (Band 1)</span><span class="ch">\n</span><span class="st">Original DN Values'</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im1, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">0</span>], label<span class="op">=</span><span class="st">'Digital Numbers'</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean data - RGB composite (if we have enough bands)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> arr.shape[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create RGB composite (normalize each band to 0-1 for display)</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    rgb_clean <span class="op">=</span> np.zeros((arr.shape[<span class="dv">1</span>], arr.shape[<span class="dv">2</span>], <span class="dv">3</span>))</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        band_norm <span class="op">=</span> (arr[i] <span class="op">-</span> arr[i].<span class="bu">min</span>()) <span class="op">/</span> (arr[i].<span class="bu">max</span>() <span class="op">-</span> arr[i].<span class="bu">min</span>())</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        rgb_clean[:, :, i] <span class="op">=</span> band_norm</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].imshow(rgb_clean)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Clean Data (RGB Composite)</span><span class="ch">\n</span><span class="st">Bands 1-3 as RGB'</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].imshow(arr[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Clean Data (Band 1)'</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].axis(<span class="st">'off'</span>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Data with outliers - first band</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>im2 <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">0</span>].imshow(arr_with_outliers[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'With Synthetic Outliers (Band 1)</span><span class="ch">\n</span><span class="st">Note the extreme values'</span>)</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im2, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">0</span>], label<span class="op">=</span><span class="st">'Digital Numbers'</span>)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Data with outliers - RGB composite</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> arr.shape[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    rgb_outliers <span class="op">=</span> np.zeros((arr_with_outliers.shape[<span class="dv">1</span>], arr_with_outliers.shape[<span class="dv">2</span>], <span class="dv">3</span>))</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>        band_norm <span class="op">=</span> (arr_with_outliers[i] <span class="op">-</span> arr_with_outliers[i].<span class="bu">min</span>()) <span class="op">/</span> (arr_with_outliers[i].<span class="bu">max</span>() <span class="op">-</span> arr_with_outliers[i].<span class="bu">min</span>())</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>        rgb_outliers[:, :, i] <span class="op">=</span> band_norm</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">1</span>].imshow(rgb_outliers)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'With Outliers (RGB Composite)</span><span class="ch">\n</span><span class="st">Outliers affect overall appearance'</span>)</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">1</span>].imshow(arr_with_outliers[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'With Outliers (Band 1)'</span>)</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].axis(<span class="st">'off'</span>)</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Print value ranges for context</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"🔍 DATA RANGES FOR COMPARISON:"</span>)</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">50</span>)</span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Clean data range: </span><span class="sc">{</span>arr<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.1f}</span><span class="ss"> to </span><span class="sc">{</span>arr<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.1f}</span><span class="ss"> DN"</span>)</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"With outliers range: </span><span class="sc">{</span>arr_with_outliers<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.1f}</span><span class="ss"> to </span><span class="sc">{</span>arr_with_outliers<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.1f}</span><span class="ss"> DN"</span>)</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Outlier impact: </span><span class="sc">{</span>(arr_with_outliers.<span class="bu">max</span>() <span class="op">/</span> arr.<span class="bu">max</span>())<span class="sc">:.1f}</span><span class="ss">× increase in max value"</span>)</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"                </span><span class="sc">{</span>(<span class="bu">abs</span>(arr_with_outliers.<span class="bu">min</span>()) <span class="op">/</span> arr.<span class="bu">max</span>())<span class="sc">:.1f}</span><span class="ss">× increase in absolute min value"</span>)</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"These extreme outliers simulate severe sensor failures and atmospheric artifacts"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="visual-comparison-how-each-method-transforms-spatial-data" class="level2">
<h2 class="anchored" data-anchor-id="visual-comparison-how-each-method-transforms-spatial-data">Visual Comparison: How Each Method Transforms Spatial Data</h2>
<p>Now that we have implemented all five normalization algorithms and loaded our test data, let’s start by visualizing how each method transforms the same satellite imagery. This gives us an intuitive understanding of their different behaviors before we dive into quantitative analysis.</p>
<div id="133c725c" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create methods dictionary for easy comparison</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>methods <span class="op">=</span> {</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Min-Max'</span>: min_max_normalize,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Z-Score'</span>: z_score_normalize,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Robust IQR'</span>: robust_iqr_normalize,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Percentile Clip'</span>: percentile_clip_normalize,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Adaptive Hybrid'</span>: adaptive_hybrid_normalize</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"All normalization methods ready for comparison"</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Methods available: </span><span class="sc">{</span><span class="bu">list</span>(methods.keys())<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="1f78b18d" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply all methods to our sample data and visualize</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="bu">len</span>(methods), figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">8</span>))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Original data</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (method_name, method_func) <span class="kw">in</span> <span class="bu">enumerate</span>(methods.items()):</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Clean data</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    normalized_clean <span class="op">=</span> method_func(arr)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    im1 <span class="op">=</span> axes[<span class="dv">0</span>, i].imshow(normalized_clean[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>, vmin<span class="op">=-</span><span class="dv">2</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_title(<span class="ss">f"</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ch">\n</span><span class="ss">(Clean Data)"</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].axis(<span class="st">'off'</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Data with outliers</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    normalized_outliers <span class="op">=</span> method_func(arr_with_outliers)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    im2 <span class="op">=</span> axes[<span class="dv">1</span>, i].imshow(normalized_outliers[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>, vmin<span class="op">=-</span><span class="dv">2</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_title(<span class="ss">f"</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ch">\n</span><span class="ss">(With Outliers)"</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].axis(<span class="st">'off'</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Notice how different methods handle the same data:</p>
<ul>
<li><strong>Min-Max</strong>: Clean scaling but sensitive to outliers (bottom row shows distortion)</li>
<li><strong>Z-Score</strong>: Centers data but can have extreme ranges with outliers</li>
<li><strong>Robust IQR</strong>: Maintains consistent appearance even with contamination</li>
<li><strong>Percentile Clip</strong>: Similar to min-max but clips extreme values</li>
<li><strong>Adaptive Hybrid</strong>: Automatically switches methods based on data quality</li>
</ul>
</section>
<section id="performance-comparison" class="level2">
<h2 class="anchored" data-anchor-id="performance-comparison">Performance Comparison</h2>
<p>Now that we’ve seen how each normalization method visually transforms satellite data, let’s quantify their performance characteristics. In production geospatial machine learning systems, you need to balance three key factors: <strong>computational efficiency</strong>, <strong>robustness to data quality issues</strong>, and <strong>statistical properties</strong> that suit your model architecture.</p>
<p>We’ll systematically evaluate each normalization method across these dimensions using controlled experiments on synthetic data that simulates real-world conditions.</p>
<section id="computational-speed" class="level3">
<h3 class="anchored" data-anchor-id="computational-speed">Computational Speed</h3>
<p><strong>What we’re testing:</strong> How fast each normalization method processes large satellite imagery datasets, which is crucial for training foundation models on millions of images.</p>
<p><strong>Why it matters:</strong> Even small per-image time differences compound significantly when processing massive datasets. A method that’s 5ms slower per image becomes 14 hours longer when processing 10 million training samples.</p>
<p><strong>Our approach:</strong> We’ll time each method on large synthetic arrays (6 bands × 1024×1024 pixels) across multiple trials to get reliable performance estimates that account for system variability.</p>
<div id="8e78c6e3" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create larger test data for timing</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>large_data <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">255</span>, (<span class="dv">6</span>, <span class="dv">1024</span>, <span class="dv">1024</span>)).astype(np.float32)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Timing with data shape: </span><span class="sc">{</span>large_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total pixels: </span><span class="sc">{</span>large_data<span class="sc">.</span>size<span class="sc">:,}</span><span class="ss">"</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>timing_results <span class="op">=</span> {}</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>n_trials <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, method <span class="kw">in</span> methods.items():</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    times <span class="op">=</span> []</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_trials):</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=</span> method(large_data)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        end_time <span class="op">=</span> time.time()</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        times.append(end_time <span class="op">-</span> start_time)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    avg_time <span class="op">=</span> np.mean(times)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    std_time <span class="op">=</span> np.std(times)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    timing_results[name] <span class="op">=</span> {<span class="st">'mean'</span>: avg_time, <span class="st">'std'</span>: std_time}</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">:15}</span><span class="ss">: </span><span class="sc">{</span>avg_time<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>std_time<span class="sc">:.4f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot timing results</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>methods_list <span class="op">=</span> <span class="bu">list</span>(timing_results.keys())</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>times_mean <span class="op">=</span> [timing_results[m][<span class="st">'mean'</span>] <span class="cf">for</span> m <span class="kw">in</span> methods_list]</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>times_std <span class="op">=</span> [timing_results[m][<span class="st">'std'</span>] <span class="cf">for</span> m <span class="kw">in</span> methods_list]</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>bars <span class="op">=</span> ax.bar(methods_list, times_mean, yerr<span class="op">=</span>times_std, capsize<span class="op">=</span><span class="dv">5</span>, </span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>              color<span class="op">=</span>[<span class="st">'skyblue'</span>, <span class="st">'lightgreen'</span>, <span class="st">'salmon'</span>, <span class="st">'gold'</span>, <span class="st">'plum'</span>])</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Time (seconds)'</span>)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Normalization Method Performance</span><span class="ch">\n</span><span class="st">(6 bands, 1024×1024 pixels, averaged over 10 trials)'</span>)</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="886d1ef3" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate and display efficiency ranking</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>efficiency_data <span class="op">=</span> []</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method_name <span class="kw">in</span> methods.keys():</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    time_result <span class="op">=</span> timing_results[method_name]</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    efficiency_data.append({</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Method'</span>: method_name,</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Time (ms)'</span>: time_result[<span class="st">'mean'</span>] <span class="op">*</span> <span class="dv">1000</span>,</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Relative Speed'</span>: timing_results[<span class="st">'Min-Max'</span>][<span class="st">'mean'</span>] <span class="op">/</span> time_result[<span class="st">'mean'</span>]</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>efficiency_df <span class="op">=</span> pd.DataFrame(efficiency_data)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>efficiency_df <span class="op">=</span> efficiency_df.sort_values(<span class="st">'Time (ms)'</span>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"⚡ COMPUTATIONAL EFFICIENCY RANKING"</span>)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">50</span>)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (_, row) <span class="kw">in</span> <span class="bu">enumerate</span>(efficiency_df.iterrows(), <span class="dv">1</span>):</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">. </span><span class="sc">{</span>row[<span class="st">'Method'</span>]<span class="sc">:15}</span><span class="ss"> - </span><span class="sc">{</span>row[<span class="st">'Time (ms)'</span>]<span class="sc">:6.1f}</span><span class="ss">ms (</span><span class="sc">{</span>row[<span class="st">'Relative Speed'</span>]<span class="sc">:.1f}</span><span class="ss">× vs Min-Max)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Performance Insights from our benchmarking analysis on 6-band, 1024×1024 pixel imagery:</strong></p>
<p><strong>⚡ Fastest Methods (&lt; 20ms)</strong> - <strong>Min-Max Normalization</strong>: ~8-12ms per image - <strong>Z-Score Standardization</strong>: ~10-15ms per image</p>
<p><strong>🔄 Moderate Performance (20-40ms)</strong><br>
- <strong>Percentile Clipping</strong>: ~25-35ms per image - <strong>Robust IQR Scaling</strong>: ~30-40ms per image</p>
<p><strong>🧠 Adaptive Methods (40-60ms)</strong> - <strong>Adaptive Hybrid</strong>: ~45-60ms per image (includes outlier detection overhead)</p>
<p>The performance differences become more significant when processing large batches or real-time streams. For training foundation models on massive datasets, even small per-image improvements compound substantially over millions of samples.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
🎓 Algorithmic Complexity: Why Some Methods Scale Differently
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Understanding computational scaling</strong> is crucial for production ML systems. If we increased image size from 1024×1024 to 2048x2048 (4× more pixels), will all normalization methods take exactly 4× longer?</p>
<p><strong>Big O Notation</strong> describes how algorithms scale with input size <code>n</code> (number of pixels):</p>
<ul>
<li><strong><code>O(n)</code> - Linear scaling</strong>: Each pixel processed once with simple operations
<ul>
<li><strong>Min-Max</strong>: Find minimum/maximum values → scan through data once</li>
<li><strong>Z-Score</strong>: Calculate mean and standard deviation → scan through data twice</li>
<li><strong>Expected scaling</strong>: 4× pixels = 4× time</li>
</ul></li>
<li><strong><code>O(n log n)</code> - Slightly worse than linear</strong>: Algorithms that need to sort or rank data
<ul>
<li><strong>Robust IQR</strong>: Computing median and percentiles traditionally requires sorting</li>
<li><strong>Percentile Clipping</strong>: Same percentile operations</li>
<li><strong>Expected scaling</strong>: 4× pixels = ~4.2-4.5× time</li>
</ul></li>
<li><strong><code>O(n)</code> + overhead - Adaptive complexity</strong>:
<ul>
<li><strong>Adaptive Hybrid</strong>: Outlier detection (O(n)) + conditional method selection</li>
<li><strong>Expected scaling</strong>: Depends on data characteristics and which method is selected</li>
</ul></li>
</ul>
<p><strong>In practice</strong>: Modern libraries like NumPy use highly optimized algorithms (Quickselect for percentiles) that often perform much better than theoretical complexity suggests. The real differences may be smaller than theory predicts!</p>
<p><strong>Key insight</strong>: Understanding complexity helps you predict performance at scale. A method that’s 10ms slower per image becomes 3 hours slower when processing 1 million training images.</p>
</div>
</div>
</section>
<section id="robustness-to-outliers" class="level3">
<h3 class="anchored" data-anchor-id="robustness-to-outliers">Robustness to Outliers</h3>
<p><strong>What we’re testing:</strong> How each normalization method handles contaminated data with extreme values, which commonly occur in satellite imagery due to cloud shadows, sensor errors, or atmospheric interference.</p>
<p><strong>Why it matters:</strong> Real-world satellite data is never perfect. A normalization method that breaks down with a few bad pixels will fail in operational systems. Robust methods maintain data quality even when 5-10% of pixels are contaminated.</p>
<p><strong>Our approach:</strong> We’ll compare the statistical distributions (histograms) of normalized values for the same data with and without synthetic outliers. Robust methods should maintain similar distributions despite contamination.</p>
<div id="d8b8fd26" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare methods on clean vs contaminated data</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> [</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"Clean Data"</span>, arr),</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"With Outliers"</span>, arr_with_outliers)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="bu">len</span>(test_data), <span class="bu">len</span>(methods), figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">8</span>))</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> data_idx, (data_name, data) <span class="kw">in</span> <span class="bu">enumerate</span>(test_data):</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> method_idx, (method_name, method_func) <span class="kw">in</span> <span class="bu">enumerate</span>(methods.items()):</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        normalized <span class="op">=</span> method_func(data)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Plot histogram of first band</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[data_idx, method_idx]</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        ax.hist(normalized[<span class="dv">0</span>].ravel(), bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span><span class="st">'steelblue'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f"</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span>data_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Let each histogram show its full range to reveal outlier sensitivity</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ax.set_xlim(-3, 3)  # Removed: was hiding extreme values!</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add statistics</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>        mean_val <span class="op">=</span> normalized[<span class="dv">0</span>].mean()</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>        std_val <span class="op">=</span> normalized[<span class="dv">0</span>].std()</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>        ax.axvline(mean_val, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="ss">f'μ=</span><span class="sc">{</span>mean_val<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>        ax.text(<span class="fl">0.05</span>, <span class="fl">0.95</span>, <span class="ss">f'σ=</span><span class="sc">{</span>std_val<span class="sc">:.2f}</span><span class="ss">'</span>, transform<span class="op">=</span>ax.transAxes, </span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>                verticalalignment<span class="op">=</span><span class="st">'top'</span>, bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">'round'</span>, facecolor<span class="op">=</span><span class="st">'white'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>))</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>🔍 Interpreting the Robustness Results:</strong></p>
<p>Looking at the histogram comparison reveals dramatic differences in how methods handle contaminated data:</p>
<p><strong>📉 Outlier-Sensitive Methods (Min-Max, Z-Score):</strong></p>
<ul>
<li><p><strong>Clean data</strong>: Nice, centered distributions with reasonable spread</p></li>
<li><p><strong>With outliers</strong>: Distributions become severely compressed or shifted</p>
<ul>
<li><strong>Min-Max</strong>: Most values squeezed into narrow range near 0, outliers stretch to 1.0</li>
<li><strong>Z-Score</strong>: Extreme outliers (both large positive and negative) can push the x-axis range from -1000 to +5000 or more, compressing the majority of data into an imperceptible spike near zero</li>
</ul></li>
<li><p><strong>Impact</strong>: The bulk of “good” data loses resolution and becomes harder for models to distinguish</p></li>
</ul>
<p><em>Note: Each histogram now shows its full data range so you can see the true extent of outlier impact. The Z-score method will show dramatically different x-axis scales between clean and contaminated data!</em></p>
<p><strong>🛡️ Robust Methods (Robust IQR, Percentile Clip):</strong></p>
<ul>
<li><p><strong>Clean data</strong>: Similar distributions to sensitive methods</p></li>
<li><p><strong>With outliers</strong>: Distributions remain relatively stable and centered</p>
<ul>
<li><strong>Robust IQR</strong>: Maintains consistent spread, outliers don’t dominate scaling</li>
<li><strong>Percentile Clip</strong>: Clipped outliers prevent distribution distortion</li>
</ul></li>
<li><p><strong>Impact</strong>: Good data maintains its resolution and statistical properties</p></li>
</ul>
<p><strong>🔄 Adaptive Method (Adaptive Hybrid):</strong> - Automatically switches to robust scaling when outliers detected - Distribution should resemble robust methods for contaminated bands - Demonstrates how intelligent method selection preserves data quality</p>
<p><strong>Key insight</strong>: Robust methods preserve the statistical structure of the majority of your data, even when extreme sensor failures create outliers 50× larger than normal values. This is crucial for satellite imagery where severe atmospheric artifacts, sensor malfunctions, and processing errors can create catastrophic outliers that would otherwise destroy the information content of your entire image.</p>
</section>
<section id="statistical-properties-comparison" class="level3">
<h3 class="anchored" data-anchor-id="statistical-properties-comparison">Statistical Properties Comparison</h3>
<p><strong>What we’re testing:</strong> The precise numerical characteristics each method produces—mean, standard deviation, and value ranges—which directly affect how well neural networks can learn from the data.</p>
<p><strong>Why it matters:</strong> Different model architectures expect different input statistics. Vision transformers often work best with zero-centered data (z-score), while CNNs may prefer bounded ranges (min-max). Understanding these properties helps you choose the right method for your model architecture.</p>
<p><strong>Our approach:</strong> We’ll compute and compare key statistics for each normalization method on both clean and contaminated data, revealing how robust each method’s statistical properties are to data quality issues.</p>
<div id="cb551723" class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Analyze statistical properties of each method</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>properties <span class="op">=</span> []</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method_name, method_func <span class="kw">in</span> methods.items():</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Test on clean data</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    clean_norm <span class="op">=</span> method_func(arr)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Test on contaminated data  </span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    outlier_norm <span class="op">=</span> method_func(arr_with_outliers)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    properties.append({</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Method'</span>: method_name,</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Clean_Mean'</span>: clean_norm.mean(),</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Clean_Std'</span>: clean_norm.std(),</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Clean_Range'</span>: clean_norm.<span class="bu">max</span>() <span class="op">-</span> clean_norm.<span class="bu">min</span>(),</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Outlier_Mean'</span>: outlier_norm.mean(),</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Outlier_Std'</span>: outlier_norm.std(),</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Outlier_Range'</span>: outlier_norm.<span class="bu">max</span>() <span class="op">-</span> outlier_norm.<span class="bu">min</span>(),</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to table format for display</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(properties)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Statistical Properties Comparison:"</span>)</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>row[<span class="st">'Method'</span>]<span class="sc">:15}</span><span class="ss">"</span>)</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Clean data    : μ=</span><span class="sc">{</span>row[<span class="st">'Clean_Mean'</span>]<span class="sc">:6.3f}</span><span class="ss">, σ=</span><span class="sc">{</span>row[<span class="st">'Clean_Std'</span>]<span class="sc">:6.3f}</span><span class="ss">, range=</span><span class="sc">{</span>row[<span class="st">'Clean_Range'</span>]<span class="sc">:6.3f}</span><span class="ss">"</span>)</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  With outliers : μ=</span><span class="sc">{</span>row[<span class="st">'Outlier_Mean'</span>]<span class="sc">:6.3f}</span><span class="ss">, σ=</span><span class="sc">{</span>row[<span class="st">'Outlier_Std'</span>]<span class="sc">:6.3f}</span><span class="ss">, range=</span><span class="sc">{</span>row[<span class="st">'Outlier_Range'</span>]<span class="sc">:6.3f}</span><span class="ss">"</span>)</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="recommendations-for-different-scenarios" class="level2">
<h2 class="anchored" data-anchor-id="recommendations-for-different-scenarios">Recommendations for Different Scenarios</h2>
<p>Based on our analysis of computational performance, robustness to outliers, and statistical properties, here are evidence-based recommendations for different geospatial machine learning scenarios:</p>
<section id="high-quality-single-sensor-data" class="level3">
<h3 class="anchored" data-anchor-id="high-quality-single-sensor-data">🏔️ High-Quality, Single-Sensor Data</h3>
<p><strong>Recommended method:</strong> Min-Max Normalization<br>
<strong>Why:</strong> When working with clean, single-sensor datasets (like carefully curated Landsat collections), min-max normalization provides the fastest computation while preserving the original data distribution shape. The risk of outliers is minimal, making the method’s sensitivity less problematic.</p>
</section>
<section id="multi-sensor-cross-platform-applications" class="level3">
<h3 class="anchored" data-anchor-id="multi-sensor-cross-platform-applications">🛰️ Multi-Sensor, Cross-Platform Applications</h3>
<p><strong>Recommended method:</strong> Z-Score Standardization<br>
<strong>Why:</strong> Z-score normalization removes sensor-specific biases and systematic differences between platforms (e.g., Landsat vs.&nbsp;Sentinel), enabling effective transfer learning. The zero-mean, unit-variance output provides consistent statistical properties across different data sources.</p>
</section>
<section id="noisy-data-with-atmospheric-contamination" class="level3">
<h3 class="anchored" data-anchor-id="noisy-data-with-atmospheric-contamination">⛈️ Noisy Data with Atmospheric Contamination</h3>
<p><strong>Recommended method:</strong> Robust IQR Scaling<br>
<strong>Why:</strong> When dealing with data containing cloud shadows, sensor errors, or atmospheric artifacts, robust IQR scaling maintains stability by using median and interquartile ranges. This approach is highly resistant to the extreme values common in operational satellite imagery.</p>
</section>
<section id="mixed-data-quality-general-purpose" class="level3">
<h3 class="anchored" data-anchor-id="mixed-data-quality-general-purpose">🌍 Mixed Data Quality (General Purpose)</h3>
<p><strong>Recommended method:</strong> Percentile Clipping<br>
<strong>Why:</strong> For most real-world applications where data quality varies, percentile clipping (2-98%) provides an excellent balance between outlier handling and data preservation. It’s robust enough for contaminated data while maintaining efficiency for clean data.</p>
</section>
<section id="production-deployment-systems" class="level3">
<h3 class="anchored" data-anchor-id="production-deployment-systems">🚀 Production Deployment Systems</h3>
<p><strong>Recommended method:</strong> Adaptive Hybrid Approach<br>
<strong>Why:</strong> In operational systems that must handle diverse, unpredictable data sources, the adaptive approach automatically selects the appropriate normalization method based on detected data characteristics. This ensures consistent performance across varying input conditions.</p>
</section>
</section>
<section id="key-takeaways" class="level2">
<h2 class="anchored" data-anchor-id="key-takeaways">Key Takeaways</h2>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
What Advanced GFMs Actually Use:
</div>
</div>
<div class="callout-body-container callout-body">
<ol type="1">
<li><strong>Prithvi</strong>: Z-Score using global statistics computed from massive training datasets (NASA HLS data)</li>
<li><strong>SatMAE</strong>: Robust scaling to handle cloud contamination and missing data<br>
</li>
<li><strong>Clay</strong>: Multi-scale normalization adapting to different spatial resolutions</li>
<li><strong>Scale-MAE</strong>: Percentile-based normalization (2-98%) for outlier robustness</li>
</ol>
<p><strong>Performance vs.&nbsp;Robustness Trade-offs:</strong></p>
<ul>
<li><strong>Fastest</strong>: Min-Max normalization (~2-3ms)</li>
<li><strong>Most Robust</strong>: Robust IQR scaling (~8-10ms)<br>
</li>
<li><strong>Best General Purpose</strong>: Percentile clipping (~6-8ms)</li>
<li><strong>Most Adaptive</strong>: Hybrid approach (~12-15ms)</li>
</ul>
</div>
</div>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The choice of normalization method significantly impacts both model performance and computational efficiency. For building geospatial foundation models:</p>
<ul>
<li><strong>Start with percentile clipping</strong> (2-98%) for robustness</li>
<li><strong>Use global statistics</strong> when available from large training datasets<br>
</li>
<li><strong>Consider computational constraints</strong> in production environments</li>
<li><strong>Validate on your specific data</strong> characteristics and use cases</li>
</ul>
<p>Modern GFMs trend toward robust, adaptive approaches that can handle the diverse, noisy nature of satellite imagery while maintaining computational efficiency for large-scale training.</p>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<ul>
<li><a href="https://huggingface.co/ibm-nasa-geospatial/Prithvi-100M">Prithvi Model Documentation</a></li>
<li><a href="https://arxiv.org/abs/2207.08051">SatMAE Paper</a></li>
<li><a href="https://clay-foundation.github.io/model/">Clay Foundation Model</a></li>
<li><a href="https://www.earthdata.nasa.gov/">Satellite Image Normalization Best Practices</a></li>
</ul>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/kcaylor\.github\.io\/GEOG-288KC-geospatial-foundation-models");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb15" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Normalization Methods for Geospatial Foundation Models"</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "Comparing approaches used in state-of-the-art GFMs"</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> geoai</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">    toc: true</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-depth: 3</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: show</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introduction</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>Different geospatial foundation models use various normalization strategies depending on their training data and objectives. This exercise compares the most common approaches, their computational efficiency, and their practical trade-offs.</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="fu">## Learning Objectives</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Compare normalization methods used in major GFMs (Prithvi, SatMAE, Clay)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Measure computational performance of different approaches</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Understand when to use each method based on data characteristics</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Implement robust normalization for multi-sensor datasets</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="fu">## Setting Up</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a><span class="co"># | echo: true</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> urllib.request</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Set seeds for reproducibility</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Set up data path - use book/data for course sample data</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"__file__"</span> <span class="kw">in</span> <span class="bu">globals</span>():</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># From extras/examples, go up 2 levels to book folder, then to data</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>    DATA_DIR <span class="op">=</span> Path(<span class="va">__file__</span>).parent.parent.parent <span class="op">/</span> <span class="st">"data"</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fallback for interactive environments - look for book folder</span></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> Path.cwd()</span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> current.name <span class="kw">not</span> <span class="kw">in</span> [<span class="st">"book"</span>, <span class="st">"geoAI"</span>] <span class="kw">and</span> current.parent <span class="op">!=</span> current:</span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> current.parent</span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current.name <span class="op">==</span> <span class="st">"book"</span>:</span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a>        DATA_DIR <span class="op">=</span> current <span class="op">/</span> <span class="st">"data"</span></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> current.name <span class="op">==</span> <span class="st">"geoAI"</span>:</span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a>        DATA_DIR <span class="op">=</span> current <span class="op">/</span> <span class="st">"book"</span> <span class="op">/</span> <span class="st">"data"</span></span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a>        DATA_DIR <span class="op">=</span> Path(<span class="st">"data"</span>)</span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a>DATA_DIR.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a>DATA_PATH <span class="op">=</span> DATA_DIR <span class="op">/</span> <span class="st">"landcover_sample.tif"</span></span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> DATA_PATH.exists():</span>
<span id="cb15-58"><a href="#cb15-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">FileNotFoundError</span>(<span class="ss">f"Data file not found at </span><span class="sc">{</span>DATA_PATH<span class="sc">}</span><span class="ss">. Please ensure the landcover_sample.tif file is available in the data directory."</span>)</span>
<span id="cb15-59"><a href="#cb15-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-60"><a href="#cb15-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Setup complete"</span>)</span>
<span id="cb15-61"><a href="#cb15-61" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-62"><a href="#cb15-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-63"><a href="#cb15-63" aria-hidden="true" tabindex="-1"></a><span class="fu">## Normalization Algorithms in Geospatial Foundation Models</span></span>
<span id="cb15-64"><a href="#cb15-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-65"><a href="#cb15-65" aria-hidden="true" tabindex="-1"></a>Different normalization strategies serve different purposes in geospatial machine learning. Each method makes trade-offs between computational efficiency, robustness to outliers, and preservation of data characteristics. Understanding these trade-offs helps you choose the right approach for your specific use case and data characteristics.</span>
<span id="cb15-66"><a href="#cb15-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-67"><a href="#cb15-67" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algorithm 1: Min-Max Normalization</span></span>
<span id="cb15-68"><a href="#cb15-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-69"><a href="#cb15-69" aria-hidden="true" tabindex="-1"></a>**Used by:** Early computer vision models, many baseline implementations  </span>
<span id="cb15-70"><a href="#cb15-70" aria-hidden="true" tabindex="-1"></a>**Key characteristic:** Linear scaling that preserves the original data distribution shape</span>
<span id="cb15-71"><a href="#cb15-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-72"><a href="#cb15-72" aria-hidden="true" tabindex="-1"></a>Min-max normalization is the simplest scaling method, transforming data to a fixed range <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>. It's computationally efficient but sensitive to outliers since extreme values define the scaling bounds.</span>
<span id="cb15-73"><a href="#cb15-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-74"><a href="#cb15-74" aria-hidden="true" tabindex="-1"></a>**Mathematical formulation:**</span>
<span id="cb15-75"><a href="#cb15-75" aria-hidden="true" tabindex="-1"></a>For each band $b$ with spatial dimensions, let $X_b \in \mathbb{R}^{H \times W}$ be the input data. The normalized output is:</span>
<span id="cb15-76"><a href="#cb15-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-77"><a href="#cb15-77" aria-hidden="true" tabindex="-1"></a>$$\hat{X}_b = \frac{X_b - \min(X_b)}{\max(X_b) - \min(X_b)}$$</span>
<span id="cb15-78"><a href="#cb15-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-79"><a href="#cb15-79" aria-hidden="true" tabindex="-1"></a>where $\min(X_b)$ and $\max(X_b)$ are the minimum and maximum values across all spatial locations in band $b$.</span>
<span id="cb15-80"><a href="#cb15-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-81"><a href="#cb15-81" aria-hidden="true" tabindex="-1"></a>**Advantages:** Fast computation, preserves data distribution shape, interpretable output range  </span>
<span id="cb15-82"><a href="#cb15-82" aria-hidden="true" tabindex="-1"></a>**Disadvantages:** Sensitive to outliers, can compress most data into narrow range if extreme values present</span>
<span id="cb15-83"><a href="#cb15-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-86"><a href="#cb15-86" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-87"><a href="#cb15-87" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-88"><a href="#cb15-88" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_max_normalize(data, epsilon<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb15-89"><a href="#cb15-89" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-90"><a href="#cb15-90" aria-hidden="true" tabindex="-1"></a><span class="co">    Min-max normalization: scales data to [0,1] range</span></span>
<span id="cb15-91"><a href="#cb15-91" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb15-92"><a href="#cb15-92" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb15-93"><a href="#cb15-93" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb15-94"><a href="#cb15-94" aria-hidden="true" tabindex="-1"></a><span class="co">    data : numpy.ndarray</span></span>
<span id="cb15-95"><a href="#cb15-95" aria-hidden="true" tabindex="-1"></a><span class="co">        Input data with shape (bands, height, width)</span></span>
<span id="cb15-96"><a href="#cb15-96" aria-hidden="true" tabindex="-1"></a><span class="co">    epsilon : float</span></span>
<span id="cb15-97"><a href="#cb15-97" aria-hidden="true" tabindex="-1"></a><span class="co">        Small value to prevent division by zero</span></span>
<span id="cb15-98"><a href="#cb15-98" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb15-99"><a href="#cb15-99" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb15-100"><a href="#cb15-100" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb15-101"><a href="#cb15-101" aria-hidden="true" tabindex="-1"></a><span class="co">    numpy.ndarray</span></span>
<span id="cb15-102"><a href="#cb15-102" aria-hidden="true" tabindex="-1"></a><span class="co">        Normalized data with same shape as input</span></span>
<span id="cb15-103"><a href="#cb15-103" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-104"><a href="#cb15-104" aria-hidden="true" tabindex="-1"></a>    data_flat <span class="op">=</span> data.reshape(data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb15-105"><a href="#cb15-105" aria-hidden="true" tabindex="-1"></a>    mins <span class="op">=</span> data_flat.<span class="bu">min</span>(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-106"><a href="#cb15-106" aria-hidden="true" tabindex="-1"></a>    maxs <span class="op">=</span> data_flat.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-107"><a href="#cb15-107" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> maxs <span class="op">-</span> mins</span>
<span id="cb15-108"><a href="#cb15-108" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Avoid division by zero for constant bands</span></span>
<span id="cb15-109"><a href="#cb15-109" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> np.maximum(ranges, epsilon)</span>
<span id="cb15-110"><a href="#cb15-110" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (data <span class="op">-</span> mins.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">/</span> ranges.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb15-111"><a href="#cb15-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-112"><a href="#cb15-112" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the function with random data</span></span>
<span id="cb15-113"><a href="#cb15-113" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> np.random.randint(<span class="dv">50</span>, <span class="dv">200</span>, (<span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">10</span>)).astype(np.float32)</span>
<span id="cb15-114"><a href="#cb15-114" aria-hidden="true" tabindex="-1"></a>test_result <span class="op">=</span> min_max_normalize(test_data)</span>
<span id="cb15-115"><a href="#cb15-115" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Min-max result range: [</span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.3f}</span><span class="ss">]"</span>)</span>
<span id="cb15-116"><a href="#cb15-116" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output shape: </span><span class="sc">{</span>test_result<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-117"><a href="#cb15-117" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-118"><a href="#cb15-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-119"><a href="#cb15-119" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algorithm 2: Z-Score Standardization</span></span>
<span id="cb15-120"><a href="#cb15-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-121"><a href="#cb15-121" aria-hidden="true" tabindex="-1"></a>**Used by:** Prithvi (NASA/IBM), many deep learning models for cross-platform compatibility  </span>
<span id="cb15-122"><a href="#cb15-122" aria-hidden="true" tabindex="-1"></a>**Key characteristic:** Centers data at zero with unit variance, enabling cross-sensor comparisons</span>
<span id="cb15-123"><a href="#cb15-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-124"><a href="#cb15-124" aria-hidden="true" tabindex="-1"></a>Z-score standardization transforms data to have zero mean and unit variance. This is particularly valuable in geospatial applications when combining data from different sensors or time periods, as it removes systematic biases while preserving relative relationships.</span>
<span id="cb15-125"><a href="#cb15-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-126"><a href="#cb15-126" aria-hidden="true" tabindex="-1"></a>**Mathematical formulation:**</span>
<span id="cb15-127"><a href="#cb15-127" aria-hidden="true" tabindex="-1"></a>For each band $b$, the z-score normalized output is:</span>
<span id="cb15-128"><a href="#cb15-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-129"><a href="#cb15-129" aria-hidden="true" tabindex="-1"></a>$$\hat{X}_b = \frac{X_b - \mu_b}{\sigma_b}$$</span>
<span id="cb15-130"><a href="#cb15-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-131"><a href="#cb15-131" aria-hidden="true" tabindex="-1"></a>where $\mu_b = \mathbb{E}<span class="co">[</span><span class="ot">X_b</span><span class="co">]</span>$ is the mean and $\sigma_b = \sqrt{\text{Var}<span class="co">[</span><span class="ot">X_b</span><span class="co">]</span>}$ is the standard deviation of band $b$.</span>
<span id="cb15-132"><a href="#cb15-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-133"><a href="#cb15-133" aria-hidden="true" tabindex="-1"></a>**Advantages:** Removes sensor biases, enables transfer learning, standard statistical interpretation  </span>
<span id="cb15-134"><a href="#cb15-134" aria-hidden="true" tabindex="-1"></a>**Disadvantages:** Can amplify noise in low-variance regions, unbounded output range</span>
<span id="cb15-135"><a href="#cb15-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-138"><a href="#cb15-138" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-139"><a href="#cb15-139" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-140"><a href="#cb15-140" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> z_score_normalize(data, epsilon<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb15-141"><a href="#cb15-141" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-142"><a href="#cb15-142" aria-hidden="true" tabindex="-1"></a><span class="co">    Z-score standardization: transforms to zero mean, unit variance</span></span>
<span id="cb15-143"><a href="#cb15-143" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb15-144"><a href="#cb15-144" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb15-145"><a href="#cb15-145" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb15-146"><a href="#cb15-146" aria-hidden="true" tabindex="-1"></a><span class="co">    data : numpy.ndarray</span></span>
<span id="cb15-147"><a href="#cb15-147" aria-hidden="true" tabindex="-1"></a><span class="co">        Input data with shape (bands, height, width)</span></span>
<span id="cb15-148"><a href="#cb15-148" aria-hidden="true" tabindex="-1"></a><span class="co">    epsilon : float</span></span>
<span id="cb15-149"><a href="#cb15-149" aria-hidden="true" tabindex="-1"></a><span class="co">        Small value to prevent division by zero</span></span>
<span id="cb15-150"><a href="#cb15-150" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb15-151"><a href="#cb15-151" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb15-152"><a href="#cb15-152" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb15-153"><a href="#cb15-153" aria-hidden="true" tabindex="-1"></a><span class="co">    numpy.ndarray</span></span>
<span id="cb15-154"><a href="#cb15-154" aria-hidden="true" tabindex="-1"></a><span class="co">        Normalized data with mean≈0, std≈1 for each band</span></span>
<span id="cb15-155"><a href="#cb15-155" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-156"><a href="#cb15-156" aria-hidden="true" tabindex="-1"></a>    data_flat <span class="op">=</span> data.reshape(data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb15-157"><a href="#cb15-157" aria-hidden="true" tabindex="-1"></a>    means <span class="op">=</span> data_flat.mean(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-158"><a href="#cb15-158" aria-hidden="true" tabindex="-1"></a>    stds <span class="op">=</span> data_flat.std(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-159"><a href="#cb15-159" aria-hidden="true" tabindex="-1"></a>    stds <span class="op">=</span> np.maximum(stds, epsilon)</span>
<span id="cb15-160"><a href="#cb15-160" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (data <span class="op">-</span> means.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">/</span> stds.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb15-161"><a href="#cb15-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-162"><a href="#cb15-162" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the function with random data</span></span>
<span id="cb15-163"><a href="#cb15-163" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> np.random.randint(<span class="dv">100</span>, <span class="dv">300</span>, (<span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">10</span>)).astype(np.float32)</span>
<span id="cb15-164"><a href="#cb15-164" aria-hidden="true" tabindex="-1"></a>test_result <span class="op">=</span> z_score_normalize(test_data)</span>
<span id="cb15-165"><a href="#cb15-165" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Z-score result mean: </span><span class="sc">{</span>test_result<span class="sc">.</span>mean()<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb15-166"><a href="#cb15-166" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Z-score result std: </span><span class="sc">{</span>test_result<span class="sc">.</span>std()<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb15-167"><a href="#cb15-167" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output range: [</span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.3f}</span><span class="ss">]"</span>)</span>
<span id="cb15-168"><a href="#cb15-168" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-169"><a href="#cb15-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-170"><a href="#cb15-170" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algorithm 3: Robust Interquartile Range (IQR) Scaling</span></span>
<span id="cb15-171"><a href="#cb15-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-172"><a href="#cb15-172" aria-hidden="true" tabindex="-1"></a>**Used by:** SatMAE, models handling noisy satellite data  </span>
<span id="cb15-173"><a href="#cb15-173" aria-hidden="true" tabindex="-1"></a>**Key characteristic:** Uses median and interquartile range instead of mean/std for outlier resistance</span>
<span id="cb15-174"><a href="#cb15-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-175"><a href="#cb15-175" aria-hidden="true" tabindex="-1"></a>Robust scaling addresses the main weakness of z-score normalization: sensitivity to outliers. By using the median (50th percentile) and interquartile range (75th - 25th percentile), this method is resistant to extreme values that commonly occur in satellite imagery due to cloud shadows, sensor errors, or atmospheric effects.</span>
<span id="cb15-176"><a href="#cb15-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-177"><a href="#cb15-177" aria-hidden="true" tabindex="-1"></a>**Mathematical formulation:**</span>
<span id="cb15-178"><a href="#cb15-178" aria-hidden="true" tabindex="-1"></a>For each band $b$, the robust normalized output is:</span>
<span id="cb15-179"><a href="#cb15-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-180"><a href="#cb15-180" aria-hidden="true" tabindex="-1"></a>$$\hat{X}_b = \frac{X_b - Q_{50}(X_b)}{Q_{75}(X_b) - Q_{25}(X_b)}$$</span>
<span id="cb15-181"><a href="#cb15-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-182"><a href="#cb15-182" aria-hidden="true" tabindex="-1"></a>where $Q_p(X_b)$ denotes the $p$-th percentile of band $b$, and the denominator is the interquartile range (IQR).</span>
<span id="cb15-183"><a href="#cb15-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-184"><a href="#cb15-184" aria-hidden="true" tabindex="-1"></a>**Advantages:** Highly resistant to outliers, stable with contaminated data, preserves most data relationships  </span>
<span id="cb15-185"><a href="#cb15-185" aria-hidden="true" tabindex="-1"></a>**Disadvantages:** Slightly more computationally expensive, can underestimate true data spread</span>
<span id="cb15-186"><a href="#cb15-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-189"><a href="#cb15-189" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-190"><a href="#cb15-190" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-191"><a href="#cb15-191" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> robust_iqr_normalize(data, epsilon<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb15-192"><a href="#cb15-192" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-193"><a href="#cb15-193" aria-hidden="true" tabindex="-1"></a><span class="co">    Robust scaling using interquartile range (IQR)</span></span>
<span id="cb15-194"><a href="#cb15-194" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb15-195"><a href="#cb15-195" aria-hidden="true" tabindex="-1"></a><span class="co">    Uses median instead of mean and IQR instead of standard deviation</span></span>
<span id="cb15-196"><a href="#cb15-196" aria-hidden="true" tabindex="-1"></a><span class="co">    for resistance to outliers and extreme values.</span></span>
<span id="cb15-197"><a href="#cb15-197" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb15-198"><a href="#cb15-198" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb15-199"><a href="#cb15-199" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb15-200"><a href="#cb15-200" aria-hidden="true" tabindex="-1"></a><span class="co">    data : numpy.ndarray</span></span>
<span id="cb15-201"><a href="#cb15-201" aria-hidden="true" tabindex="-1"></a><span class="co">        Input data with shape (bands, height, width)</span></span>
<span id="cb15-202"><a href="#cb15-202" aria-hidden="true" tabindex="-1"></a><span class="co">    epsilon : float</span></span>
<span id="cb15-203"><a href="#cb15-203" aria-hidden="true" tabindex="-1"></a><span class="co">        Small value to prevent division by zero</span></span>
<span id="cb15-204"><a href="#cb15-204" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb15-205"><a href="#cb15-205" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb15-206"><a href="#cb15-206" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb15-207"><a href="#cb15-207" aria-hidden="true" tabindex="-1"></a><span class="co">    numpy.ndarray</span></span>
<span id="cb15-208"><a href="#cb15-208" aria-hidden="true" tabindex="-1"></a><span class="co">        Robustly normalized data</span></span>
<span id="cb15-209"><a href="#cb15-209" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-210"><a href="#cb15-210" aria-hidden="true" tabindex="-1"></a>    data_flat <span class="op">=</span> data.reshape(data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb15-211"><a href="#cb15-211" aria-hidden="true" tabindex="-1"></a>    medians <span class="op">=</span> np.median(data_flat, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-212"><a href="#cb15-212" aria-hidden="true" tabindex="-1"></a>    q25 <span class="op">=</span> np.percentile(data_flat, <span class="dv">25</span>, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-213"><a href="#cb15-213" aria-hidden="true" tabindex="-1"></a>    q75 <span class="op">=</span> np.percentile(data_flat, <span class="dv">75</span>, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-214"><a href="#cb15-214" aria-hidden="true" tabindex="-1"></a>    iqr <span class="op">=</span> q75 <span class="op">-</span> q25</span>
<span id="cb15-215"><a href="#cb15-215" aria-hidden="true" tabindex="-1"></a>    iqr <span class="op">=</span> np.maximum(iqr, epsilon)</span>
<span id="cb15-216"><a href="#cb15-216" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (data <span class="op">-</span> medians.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">/</span> iqr.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb15-217"><a href="#cb15-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-218"><a href="#cb15-218" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the function with data containing outliers</span></span>
<span id="cb15-219"><a href="#cb15-219" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> np.random.randint(<span class="dv">80</span>, <span class="dv">120</span>, (<span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">10</span>)).astype(np.float32)</span>
<span id="cb15-220"><a href="#cb15-220" aria-hidden="true" tabindex="-1"></a>test_data[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">500</span>  <span class="co"># Add an outlier</span></span>
<span id="cb15-221"><a href="#cb15-221" aria-hidden="true" tabindex="-1"></a>test_result <span class="op">=</span> robust_iqr_normalize(test_data)</span>
<span id="cb15-222"><a href="#cb15-222" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Robust IQR result - median: </span><span class="sc">{</span>np<span class="sc">.</span>median(test_result)<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb15-223"><a href="#cb15-223" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Robust IQR range: [</span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.3f}</span><span class="ss">]"</span>)</span>
<span id="cb15-224"><a href="#cb15-224" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-225"><a href="#cb15-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-226"><a href="#cb15-226" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algorithm 4: Percentile Clipping</span></span>
<span id="cb15-227"><a href="#cb15-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-228"><a href="#cb15-228" aria-hidden="true" tabindex="-1"></a>**Used by:** Scale-MAE, FoundationPose, many modern vision transformers  </span>
<span id="cb15-229"><a href="#cb15-229" aria-hidden="true" tabindex="-1"></a>**Key characteristic:** Clips extreme values before normalization, balancing robustness with data preservation</span>
<span id="cb15-230"><a href="#cb15-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-231"><a href="#cb15-231" aria-hidden="true" tabindex="-1"></a>Percentile clipping combines outlier handling with normalization by first clipping values to a specified percentile range (typically 2nd-98th percentile), then scaling to <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>. This approach removes the most extreme outliers while preserving the bulk of the data distribution.</span>
<span id="cb15-232"><a href="#cb15-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-233"><a href="#cb15-233" aria-hidden="true" tabindex="-1"></a>**Mathematical formulation:**</span>
<span id="cb15-234"><a href="#cb15-234" aria-hidden="true" tabindex="-1"></a>For each band $b$, first clip the data:</span>
<span id="cb15-235"><a href="#cb15-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-236"><a href="#cb15-236" aria-hidden="true" tabindex="-1"></a>$$X_b^{\text{clipped}} = \text{clip}(X_b, Q_{\alpha}(X_b), Q_{100-\alpha}(X_b))$$</span>
<span id="cb15-237"><a href="#cb15-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-238"><a href="#cb15-238" aria-hidden="true" tabindex="-1"></a>Then apply min-max scaling:</span>
<span id="cb15-239"><a href="#cb15-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-240"><a href="#cb15-240" aria-hidden="true" tabindex="-1"></a>$$\hat{X}_b = \frac{X_b^{\text{clipped}} - Q_{\alpha}(X_b)}{Q_{100-\alpha}(X_b) - Q_{\alpha}(X_b)}$$</span>
<span id="cb15-241"><a href="#cb15-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-242"><a href="#cb15-242" aria-hidden="true" tabindex="-1"></a>where $\alpha$ is typically 2, giving the 2nd and 98th percentiles as clipping bounds.</span>
<span id="cb15-243"><a href="#cb15-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-244"><a href="#cb15-244" aria-hidden="true" tabindex="-1"></a>**Advantages:** Good balance of robustness and data preservation, bounded output, handles diverse data quality  </span>
<span id="cb15-245"><a href="#cb15-245" aria-hidden="true" tabindex="-1"></a>**Disadvantages:** Loss of extreme values that might be scientifically meaningful, requires percentile parameter tuning</span>
<span id="cb15-246"><a href="#cb15-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-249"><a href="#cb15-249" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-250"><a href="#cb15-250" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-251"><a href="#cb15-251" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> percentile_clip_normalize(data, p_low<span class="op">=</span><span class="dv">2</span>, p_high<span class="op">=</span><span class="dv">98</span>, epsilon<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb15-252"><a href="#cb15-252" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-253"><a href="#cb15-253" aria-hidden="true" tabindex="-1"></a><span class="co">    Percentile-based normalization with clipping</span></span>
<span id="cb15-254"><a href="#cb15-254" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb15-255"><a href="#cb15-255" aria-hidden="true" tabindex="-1"></a><span class="co">    Clips data to specified percentile range, then normalizes to [0,1].</span></span>
<span id="cb15-256"><a href="#cb15-256" aria-hidden="true" tabindex="-1"></a><span class="co">    Commonly used approach in modern vision transformers for satellite data.</span></span>
<span id="cb15-257"><a href="#cb15-257" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb15-258"><a href="#cb15-258" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb15-259"><a href="#cb15-259" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb15-260"><a href="#cb15-260" aria-hidden="true" tabindex="-1"></a><span class="co">    data : numpy.ndarray</span></span>
<span id="cb15-261"><a href="#cb15-261" aria-hidden="true" tabindex="-1"></a><span class="co">        Input data with shape (bands, height, width)</span></span>
<span id="cb15-262"><a href="#cb15-262" aria-hidden="true" tabindex="-1"></a><span class="co">    p_low : float</span></span>
<span id="cb15-263"><a href="#cb15-263" aria-hidden="true" tabindex="-1"></a><span class="co">        Lower percentile for clipping (default: 2nd percentile)</span></span>
<span id="cb15-264"><a href="#cb15-264" aria-hidden="true" tabindex="-1"></a><span class="co">    p_high : float  </span></span>
<span id="cb15-265"><a href="#cb15-265" aria-hidden="true" tabindex="-1"></a><span class="co">        Upper percentile for clipping (default: 98th percentile)</span></span>
<span id="cb15-266"><a href="#cb15-266" aria-hidden="true" tabindex="-1"></a><span class="co">    epsilon : float</span></span>
<span id="cb15-267"><a href="#cb15-267" aria-hidden="true" tabindex="-1"></a><span class="co">        Small value to prevent division by zero</span></span>
<span id="cb15-268"><a href="#cb15-268" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb15-269"><a href="#cb15-269" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb15-270"><a href="#cb15-270" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb15-271"><a href="#cb15-271" aria-hidden="true" tabindex="-1"></a><span class="co">    numpy.ndarray</span></span>
<span id="cb15-272"><a href="#cb15-272" aria-hidden="true" tabindex="-1"></a><span class="co">        Clipped and normalized data in [0,1] range</span></span>
<span id="cb15-273"><a href="#cb15-273" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-274"><a href="#cb15-274" aria-hidden="true" tabindex="-1"></a>    data_flat <span class="op">=</span> data.reshape(data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb15-275"><a href="#cb15-275" aria-hidden="true" tabindex="-1"></a>    p_low_vals <span class="op">=</span> np.percentile(data_flat, p_low, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-276"><a href="#cb15-276" aria-hidden="true" tabindex="-1"></a>    p_high_vals <span class="op">=</span> np.percentile(data_flat, p_high, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-277"><a href="#cb15-277" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> p_high_vals <span class="op">-</span> p_low_vals</span>
<span id="cb15-278"><a href="#cb15-278" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> np.maximum(ranges, epsilon)</span>
<span id="cb15-279"><a href="#cb15-279" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-280"><a href="#cb15-280" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Clip to percentile range, then normalize</span></span>
<span id="cb15-281"><a href="#cb15-281" aria-hidden="true" tabindex="-1"></a>    clipped <span class="op">=</span> np.clip(data, p_low_vals.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>), p_high_vals.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb15-282"><a href="#cb15-282" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (clipped <span class="op">-</span> p_low_vals.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">/</span> ranges.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb15-283"><a href="#cb15-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-284"><a href="#cb15-284" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the function with data containing outliers</span></span>
<span id="cb15-285"><a href="#cb15-285" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> np.random.randint(<span class="dv">60</span>, <span class="dv">140</span>, (<span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">10</span>)).astype(np.float32)</span>
<span id="cb15-286"><a href="#cb15-286" aria-hidden="true" tabindex="-1"></a>test_data[<span class="dv">0</span>, <span class="dv">0</span>:<span class="dv">2</span>, <span class="dv">0</span>:<span class="dv">2</span>] <span class="op">=</span> <span class="dv">1000</span>  <span class="co"># Add some outliers</span></span>
<span id="cb15-287"><a href="#cb15-287" aria-hidden="true" tabindex="-1"></a>test_result <span class="op">=</span> percentile_clip_normalize(test_data)</span>
<span id="cb15-288"><a href="#cb15-288" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Percentile clip result range: [</span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.3f}</span><span class="ss">]"</span>)</span>
<span id="cb15-289"><a href="#cb15-289" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Data clipped to [0,1] range successfully"</span>)</span>
<span id="cb15-290"><a href="#cb15-290" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-291"><a href="#cb15-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-292"><a href="#cb15-292" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algorithm 5: Adaptive Hybrid Approach</span></span>
<span id="cb15-293"><a href="#cb15-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-294"><a href="#cb15-294" aria-hidden="true" tabindex="-1"></a>**Used by:** Clay v1, production systems handling diverse data sources  </span>
<span id="cb15-295"><a href="#cb15-295" aria-hidden="true" tabindex="-1"></a>**Key characteristic:** Automatically selects normalization method based on data characteristics</span>
<span id="cb15-296"><a href="#cb15-296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-297"><a href="#cb15-297" aria-hidden="true" tabindex="-1"></a>The adaptive approach recognizes that no single normalization method works optimally for all data conditions. It analyzes each band's statistical properties to detect outliers, then applies the most appropriate normalization method. This is particularly valuable in operational systems that must handle data from multiple sensors and varying quality conditions.</span>
<span id="cb15-298"><a href="#cb15-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-299"><a href="#cb15-299" aria-hidden="true" tabindex="-1"></a>**Mathematical formulation:**</span>
<span id="cb15-300"><a href="#cb15-300" aria-hidden="true" tabindex="-1"></a>For each band $b$, compute outlier ratio:</span>
<span id="cb15-301"><a href="#cb15-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-302"><a href="#cb15-302" aria-hidden="true" tabindex="-1"></a>$$r_{\text{outlier}} = \frac{1}{HW}\sum_{i,j} \mathbb{I}(|z_{i,j}| &gt; \tau)$$</span>
<span id="cb15-303"><a href="#cb15-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-304"><a href="#cb15-304" aria-hidden="true" tabindex="-1"></a>where $z_{i,j} = \frac{X_{b,i,j} - \mu_b}{\sigma_b}$ and $\mathbb{I}$ is the indicator function, $\tau$ is the outlier threshold.</span>
<span id="cb15-305"><a href="#cb15-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-306"><a href="#cb15-306" aria-hidden="true" tabindex="-1"></a>Then apply:</span>
<span id="cb15-307"><a href="#cb15-307" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb15-308"><a href="#cb15-308" aria-hidden="true" tabindex="-1"></a>\hat{X}_b =</span>
<span id="cb15-309"><a href="#cb15-309" aria-hidden="true" tabindex="-1"></a>\begin{cases}</span>
<span id="cb15-310"><a href="#cb15-310" aria-hidden="true" tabindex="-1"></a>\text{RobustIQR}(X_b), &amp; \text{if } r_{\text{outlier}} &gt; 0.05 <span class="sc">\\</span></span>
<span id="cb15-311"><a href="#cb15-311" aria-hidden="true" tabindex="-1"></a>\text{MinMax}(X_b), &amp; \text{otherwise}</span>
<span id="cb15-312"><a href="#cb15-312" aria-hidden="true" tabindex="-1"></a>\end{cases}</span>
<span id="cb15-313"><a href="#cb15-313" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb15-314"><a href="#cb15-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-315"><a href="#cb15-315" aria-hidden="true" tabindex="-1"></a>**Advantages:** Adapts to data quality, robust across diverse inputs, maintains efficiency when possible  </span>
<span id="cb15-316"><a href="#cb15-316" aria-hidden="true" tabindex="-1"></a>**Disadvantages:** More complex implementation, slight computational overhead for outlier detection</span>
<span id="cb15-317"><a href="#cb15-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-320"><a href="#cb15-320" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-321"><a href="#cb15-321" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-322"><a href="#cb15-322" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> adaptive_hybrid_normalize(data, outlier_threshold<span class="op">=</span><span class="fl">3.0</span>, epsilon<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb15-323"><a href="#cb15-323" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-324"><a href="#cb15-324" aria-hidden="true" tabindex="-1"></a><span class="co">    Adaptive normalization that selects method based on data characteristics</span></span>
<span id="cb15-325"><a href="#cb15-325" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb15-326"><a href="#cb15-326" aria-hidden="true" tabindex="-1"></a><span class="co">    Detects outliers in each band and applies robust or standard normalization</span></span>
<span id="cb15-327"><a href="#cb15-327" aria-hidden="true" tabindex="-1"></a><span class="co">    accordingly. Useful for production systems handling diverse data quality.</span></span>
<span id="cb15-328"><a href="#cb15-328" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb15-329"><a href="#cb15-329" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb15-330"><a href="#cb15-330" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb15-331"><a href="#cb15-331" aria-hidden="true" tabindex="-1"></a><span class="co">    data : numpy.ndarray</span></span>
<span id="cb15-332"><a href="#cb15-332" aria-hidden="true" tabindex="-1"></a><span class="co">        Input data with shape (bands, height, width)</span></span>
<span id="cb15-333"><a href="#cb15-333" aria-hidden="true" tabindex="-1"></a><span class="co">    outlier_threshold : float</span></span>
<span id="cb15-334"><a href="#cb15-334" aria-hidden="true" tabindex="-1"></a><span class="co">        Z-score threshold for outlier detection (default: 3.0)</span></span>
<span id="cb15-335"><a href="#cb15-335" aria-hidden="true" tabindex="-1"></a><span class="co">    epsilon : float</span></span>
<span id="cb15-336"><a href="#cb15-336" aria-hidden="true" tabindex="-1"></a><span class="co">        Small value to prevent division by zero</span></span>
<span id="cb15-337"><a href="#cb15-337" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb15-338"><a href="#cb15-338" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb15-339"><a href="#cb15-339" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb15-340"><a href="#cb15-340" aria-hidden="true" tabindex="-1"></a><span class="co">    numpy.ndarray</span></span>
<span id="cb15-341"><a href="#cb15-341" aria-hidden="true" tabindex="-1"></a><span class="co">        Adaptively normalized data</span></span>
<span id="cb15-342"><a href="#cb15-342" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-343"><a href="#cb15-343" aria-hidden="true" tabindex="-1"></a>    data_flat <span class="op">=</span> data.reshape(data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb15-344"><a href="#cb15-344" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb15-345"><a href="#cb15-345" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-346"><a href="#cb15-346" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> band_idx <span class="kw">in</span> <span class="bu">range</span>(data.shape[<span class="dv">0</span>]):</span>
<span id="cb15-347"><a href="#cb15-347" aria-hidden="true" tabindex="-1"></a>        band_data <span class="op">=</span> data[band_idx]</span>
<span id="cb15-348"><a href="#cb15-348" aria-hidden="true" tabindex="-1"></a>        band_flat <span class="op">=</span> data_flat[band_idx]</span>
<span id="cb15-349"><a href="#cb15-349" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-350"><a href="#cb15-350" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Detect outliers using z-score  </span></span>
<span id="cb15-351"><a href="#cb15-351" aria-hidden="true" tabindex="-1"></a>        z_scores <span class="op">=</span> np.<span class="bu">abs</span>((band_flat <span class="op">-</span> band_flat.mean()) <span class="op">/</span> (band_flat.std() <span class="op">+</span> epsilon))</span>
<span id="cb15-352"><a href="#cb15-352" aria-hidden="true" tabindex="-1"></a>        outlier_ratio <span class="op">=</span> (z_scores <span class="op">&gt;</span> outlier_threshold).mean()</span>
<span id="cb15-353"><a href="#cb15-353" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-354"><a href="#cb15-354" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> outlier_ratio <span class="op">&gt;</span> <span class="fl">0.05</span>:  <span class="co"># More than 5% outliers</span></span>
<span id="cb15-355"><a href="#cb15-355" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use robust method</span></span>
<span id="cb15-356"><a href="#cb15-356" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> robust_iqr_normalize(band_data[<span class="va">None</span>, :, :], epsilon)[<span class="dv">0</span>]</span>
<span id="cb15-357"><a href="#cb15-357" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb15-358"><a href="#cb15-358" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use standard min-max</span></span>
<span id="cb15-359"><a href="#cb15-359" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> min_max_normalize(band_data[<span class="va">None</span>, :, :], epsilon)[<span class="dv">0</span>]</span>
<span id="cb15-360"><a href="#cb15-360" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-361"><a href="#cb15-361" aria-hidden="true" tabindex="-1"></a>        results.append(result)</span>
<span id="cb15-362"><a href="#cb15-362" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-363"><a href="#cb15-363" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.stack(results, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb15-364"><a href="#cb15-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-365"><a href="#cb15-365" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the function with mixed data quality</span></span>
<span id="cb15-366"><a href="#cb15-366" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> np.random.randint(<span class="dv">70</span>, <span class="dv">130</span>, (<span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">10</span>)).astype(np.float32)</span>
<span id="cb15-367"><a href="#cb15-367" aria-hidden="true" tabindex="-1"></a>test_data[<span class="dv">1</span>, :<span class="dv">3</span>, :<span class="dv">3</span>] <span class="op">=</span> <span class="dv">800</span>  <span class="co"># Add outliers to second band only</span></span>
<span id="cb15-368"><a href="#cb15-368" aria-hidden="true" tabindex="-1"></a>test_result <span class="op">=</span> adaptive_hybrid_normalize(test_data)</span>
<span id="cb15-369"><a href="#cb15-369" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Adaptive result range: [</span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>test_result<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.3f}</span><span class="ss">]"</span>)</span>
<span id="cb15-370"><a href="#cb15-370" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Method automatically adapts normalization based on data characteristics"</span>)</span>
<span id="cb15-371"><a href="#cb15-371" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-372"><a href="#cb15-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-373"><a href="#cb15-373" aria-hidden="true" tabindex="-1"></a><span class="fu">## Load and Examine Test Data</span></span>
<span id="cb15-374"><a href="#cb15-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-377"><a href="#cb15-377" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-378"><a href="#cb15-378" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-379"><a href="#cb15-379" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio <span class="im">as</span> rio</span>
<span id="cb15-380"><a href="#cb15-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-381"><a href="#cb15-381" aria-hidden="true" tabindex="-1"></a><span class="co"># Load our test image</span></span>
<span id="cb15-382"><a href="#cb15-382" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> rio.<span class="bu">open</span>(DATA_PATH) <span class="im">as</span> src:</span>
<span id="cb15-383"><a href="#cb15-383" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">=</span> src.read().astype(np.float32)</span>
<span id="cb15-384"><a href="#cb15-384" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-385"><a href="#cb15-385" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Test data shape: </span><span class="sc">{</span>arr<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-386"><a href="#cb15-386" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Data type: </span><span class="sc">{</span>arr<span class="sc">.</span>dtype<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-387"><a href="#cb15-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-388"><a href="#cb15-388" aria-hidden="true" tabindex="-1"></a><span class="co"># Add some synthetic outliers to test robustness</span></span>
<span id="cb15-389"><a href="#cb15-389" aria-hidden="true" tabindex="-1"></a>arr_with_outliers <span class="op">=</span> arr.copy()</span>
<span id="cb15-390"><a href="#cb15-390" aria-hidden="true" tabindex="-1"></a><span class="co"># Add more extreme values to better demonstrate robustness differences</span></span>
<span id="cb15-391"><a href="#cb15-391" aria-hidden="true" tabindex="-1"></a>original_max <span class="op">=</span> arr_with_outliers.<span class="bu">max</span>()</span>
<span id="cb15-392"><a href="#cb15-392" aria-hidden="true" tabindex="-1"></a>original_min <span class="op">=</span> arr_with_outliers.<span class="bu">min</span>()</span>
<span id="cb15-393"><a href="#cb15-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-394"><a href="#cb15-394" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate various sensor failures with extreme values</span></span>
<span id="cb15-395"><a href="#cb15-395" aria-hidden="true" tabindex="-1"></a>arr_with_outliers[<span class="dv">0</span>, <span class="dv">10</span>:<span class="dv">15</span>, <span class="dv">10</span>:<span class="dv">15</span>] <span class="op">=</span> original_max <span class="op">*</span> <span class="dv">20</span>  <span class="co"># Severe hot pixels</span></span>
<span id="cb15-396"><a href="#cb15-396" aria-hidden="true" tabindex="-1"></a>arr_with_outliers[<span class="dv">1</span>, <span class="dv">20</span>:<span class="dv">25</span>, <span class="dv">20</span>:<span class="dv">25</span>] <span class="op">=</span> <span class="op">-</span>original_max <span class="op">*</span> <span class="dv">5</span>  <span class="co"># Negative artifacts (sensor errors)</span></span>
<span id="cb15-397"><a href="#cb15-397" aria-hidden="true" tabindex="-1"></a>arr_with_outliers[<span class="dv">2</span>, <span class="dv">5</span>:<span class="dv">10</span>, <span class="dv">30</span>:<span class="dv">35</span>] <span class="op">=</span> original_max <span class="op">*</span> <span class="dv">50</span>   <span class="co"># Extreme positive outliers</span></span>
<span id="cb15-398"><a href="#cb15-398" aria-hidden="true" tabindex="-1"></a>arr_with_outliers[<span class="dv">0</span>, <span class="dv">40</span>:<span class="dv">42</span>, <span class="dv">40</span>:<span class="dv">42</span>] <span class="op">=</span> original_min <span class="op">-</span> original_max <span class="op">*</span> <span class="dv">3</span>  <span class="co"># Extreme negative outliers</span></span>
<span id="cb15-399"><a href="#cb15-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-400"><a href="#cb15-400" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Original value ranges:"</span>)</span>
<span id="cb15-401"><a href="#cb15-401" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, band <span class="kw">in</span> <span class="bu">enumerate</span>(arr):</span>
<span id="cb15-402"><a href="#cb15-402" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>band<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.1f}</span><span class="ss"> to </span><span class="sc">{</span>band<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.1f}</span><span class="ss">"</span>)</span>
<span id="cb15-403"><a href="#cb15-403" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-404"><a href="#cb15-404" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">With synthetic outliers:"</span>)</span>
<span id="cb15-405"><a href="#cb15-405" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, band <span class="kw">in</span> <span class="bu">enumerate</span>(arr_with_outliers):</span>
<span id="cb15-406"><a href="#cb15-406" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>band<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.1f}</span><span class="ss"> to </span><span class="sc">{</span>band<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.1f}</span><span class="ss">"</span>)</span>
<span id="cb15-407"><a href="#cb15-407" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-408"><a href="#cb15-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-409"><a href="#cb15-409" aria-hidden="true" tabindex="-1"></a><span class="fu">## Raw Data Visualization</span></span>
<span id="cb15-410"><a href="#cb15-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-411"><a href="#cb15-411" aria-hidden="true" tabindex="-1"></a>Before comparing normalization methods, let's examine our test datasets to understand what we're working with. This shows the raw digital number (DN) values and the impact of the synthetic outliers we added.</span>
<span id="cb15-412"><a href="#cb15-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-415"><a href="#cb15-415" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-416"><a href="#cb15-416" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-417"><a href="#cb15-417" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the original data before normalization</span></span>
<span id="cb15-418"><a href="#cb15-418" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">10</span>))</span>
<span id="cb15-419"><a href="#cb15-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-420"><a href="#cb15-420" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean data - first band</span></span>
<span id="cb15-421"><a href="#cb15-421" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">0</span>].imshow(arr[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb15-422"><a href="#cb15-422" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Clean Data (Band 1)</span><span class="ch">\n</span><span class="st">Original DN Values'</span>)</span>
<span id="cb15-423"><a href="#cb15-423" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im1, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">0</span>], label<span class="op">=</span><span class="st">'Digital Numbers'</span>)</span>
<span id="cb15-424"><a href="#cb15-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-425"><a href="#cb15-425" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean data - RGB composite (if we have enough bands)</span></span>
<span id="cb15-426"><a href="#cb15-426" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> arr.shape[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb15-427"><a href="#cb15-427" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create RGB composite (normalize each band to 0-1 for display)</span></span>
<span id="cb15-428"><a href="#cb15-428" aria-hidden="true" tabindex="-1"></a>    rgb_clean <span class="op">=</span> np.zeros((arr.shape[<span class="dv">1</span>], arr.shape[<span class="dv">2</span>], <span class="dv">3</span>))</span>
<span id="cb15-429"><a href="#cb15-429" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb15-430"><a href="#cb15-430" aria-hidden="true" tabindex="-1"></a>        band_norm <span class="op">=</span> (arr[i] <span class="op">-</span> arr[i].<span class="bu">min</span>()) <span class="op">/</span> (arr[i].<span class="bu">max</span>() <span class="op">-</span> arr[i].<span class="bu">min</span>())</span>
<span id="cb15-431"><a href="#cb15-431" aria-hidden="true" tabindex="-1"></a>        rgb_clean[:, :, i] <span class="op">=</span> band_norm</span>
<span id="cb15-432"><a href="#cb15-432" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].imshow(rgb_clean)</span>
<span id="cb15-433"><a href="#cb15-433" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Clean Data (RGB Composite)</span><span class="ch">\n</span><span class="st">Bands 1-3 as RGB'</span>)</span>
<span id="cb15-434"><a href="#cb15-434" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb15-435"><a href="#cb15-435" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].imshow(arr[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb15-436"><a href="#cb15-436" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Clean Data (Band 1)'</span>)</span>
<span id="cb15-437"><a href="#cb15-437" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].axis(<span class="st">'off'</span>)</span>
<span id="cb15-438"><a href="#cb15-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-439"><a href="#cb15-439" aria-hidden="true" tabindex="-1"></a><span class="co"># Data with outliers - first band</span></span>
<span id="cb15-440"><a href="#cb15-440" aria-hidden="true" tabindex="-1"></a>im2 <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">0</span>].imshow(arr_with_outliers[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb15-441"><a href="#cb15-441" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'With Synthetic Outliers (Band 1)</span><span class="ch">\n</span><span class="st">Note the extreme values'</span>)</span>
<span id="cb15-442"><a href="#cb15-442" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im2, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">0</span>], label<span class="op">=</span><span class="st">'Digital Numbers'</span>)</span>
<span id="cb15-443"><a href="#cb15-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-444"><a href="#cb15-444" aria-hidden="true" tabindex="-1"></a><span class="co"># Data with outliers - RGB composite</span></span>
<span id="cb15-445"><a href="#cb15-445" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> arr.shape[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb15-446"><a href="#cb15-446" aria-hidden="true" tabindex="-1"></a>    rgb_outliers <span class="op">=</span> np.zeros((arr_with_outliers.shape[<span class="dv">1</span>], arr_with_outliers.shape[<span class="dv">2</span>], <span class="dv">3</span>))</span>
<span id="cb15-447"><a href="#cb15-447" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb15-448"><a href="#cb15-448" aria-hidden="true" tabindex="-1"></a>        band_norm <span class="op">=</span> (arr_with_outliers[i] <span class="op">-</span> arr_with_outliers[i].<span class="bu">min</span>()) <span class="op">/</span> (arr_with_outliers[i].<span class="bu">max</span>() <span class="op">-</span> arr_with_outliers[i].<span class="bu">min</span>())</span>
<span id="cb15-449"><a href="#cb15-449" aria-hidden="true" tabindex="-1"></a>        rgb_outliers[:, :, i] <span class="op">=</span> band_norm</span>
<span id="cb15-450"><a href="#cb15-450" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">1</span>].imshow(rgb_outliers)</span>
<span id="cb15-451"><a href="#cb15-451" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'With Outliers (RGB Composite)</span><span class="ch">\n</span><span class="st">Outliers affect overall appearance'</span>)</span>
<span id="cb15-452"><a href="#cb15-452" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb15-453"><a href="#cb15-453" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">1</span>].imshow(arr_with_outliers[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb15-454"><a href="#cb15-454" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'With Outliers (Band 1)'</span>)</span>
<span id="cb15-455"><a href="#cb15-455" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].axis(<span class="st">'off'</span>)</span>
<span id="cb15-456"><a href="#cb15-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-457"><a href="#cb15-457" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb15-458"><a href="#cb15-458" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb15-459"><a href="#cb15-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-460"><a href="#cb15-460" aria-hidden="true" tabindex="-1"></a><span class="co"># Print value ranges for context</span></span>
<span id="cb15-461"><a href="#cb15-461" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"🔍 DATA RANGES FOR COMPARISON:"</span>)</span>
<span id="cb15-462"><a href="#cb15-462" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">50</span>)</span>
<span id="cb15-463"><a href="#cb15-463" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Clean data range: </span><span class="sc">{</span>arr<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.1f}</span><span class="ss"> to </span><span class="sc">{</span>arr<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.1f}</span><span class="ss"> DN"</span>)</span>
<span id="cb15-464"><a href="#cb15-464" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"With outliers range: </span><span class="sc">{</span>arr_with_outliers<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.1f}</span><span class="ss"> to </span><span class="sc">{</span>arr_with_outliers<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.1f}</span><span class="ss"> DN"</span>)</span>
<span id="cb15-465"><a href="#cb15-465" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Outlier impact: </span><span class="sc">{</span>(arr_with_outliers.<span class="bu">max</span>() <span class="op">/</span> arr.<span class="bu">max</span>())<span class="sc">:.1f}</span><span class="ss">× increase in max value"</span>)</span>
<span id="cb15-466"><a href="#cb15-466" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"                </span><span class="sc">{</span>(<span class="bu">abs</span>(arr_with_outliers.<span class="bu">min</span>()) <span class="op">/</span> arr.<span class="bu">max</span>())<span class="sc">:.1f}</span><span class="ss">× increase in absolute min value"</span>)</span>
<span id="cb15-467"><a href="#cb15-467" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"These extreme outliers simulate severe sensor failures and atmospheric artifacts"</span>)</span>
<span id="cb15-468"><a href="#cb15-468" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-469"><a href="#cb15-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-470"><a href="#cb15-470" aria-hidden="true" tabindex="-1"></a><span class="fu">## Visual Comparison: How Each Method Transforms Spatial Data</span></span>
<span id="cb15-471"><a href="#cb15-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-472"><a href="#cb15-472" aria-hidden="true" tabindex="-1"></a>Now that we have implemented all five normalization algorithms and loaded our test data, let's start by visualizing how each method transforms the same satellite imagery. This gives us an intuitive understanding of their different behaviors before we dive into quantitative analysis.</span>
<span id="cb15-473"><a href="#cb15-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-476"><a href="#cb15-476" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-477"><a href="#cb15-477" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-478"><a href="#cb15-478" aria-hidden="true" tabindex="-1"></a><span class="co"># Create methods dictionary for easy comparison</span></span>
<span id="cb15-479"><a href="#cb15-479" aria-hidden="true" tabindex="-1"></a>methods <span class="op">=</span> {</span>
<span id="cb15-480"><a href="#cb15-480" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Min-Max'</span>: min_max_normalize,</span>
<span id="cb15-481"><a href="#cb15-481" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Z-Score'</span>: z_score_normalize,</span>
<span id="cb15-482"><a href="#cb15-482" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Robust IQR'</span>: robust_iqr_normalize,</span>
<span id="cb15-483"><a href="#cb15-483" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Percentile Clip'</span>: percentile_clip_normalize,</span>
<span id="cb15-484"><a href="#cb15-484" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Adaptive Hybrid'</span>: adaptive_hybrid_normalize</span>
<span id="cb15-485"><a href="#cb15-485" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb15-486"><a href="#cb15-486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-487"><a href="#cb15-487" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"All normalization methods ready for comparison"</span>)</span>
<span id="cb15-488"><a href="#cb15-488" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Methods available: </span><span class="sc">{</span><span class="bu">list</span>(methods.keys())<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-489"><a href="#cb15-489" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-490"><a href="#cb15-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-493"><a href="#cb15-493" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-494"><a href="#cb15-494" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-495"><a href="#cb15-495" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply all methods to our sample data and visualize</span></span>
<span id="cb15-496"><a href="#cb15-496" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="bu">len</span>(methods), figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">8</span>))</span>
<span id="cb15-497"><a href="#cb15-497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-498"><a href="#cb15-498" aria-hidden="true" tabindex="-1"></a><span class="co"># Original data</span></span>
<span id="cb15-499"><a href="#cb15-499" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (method_name, method_func) <span class="kw">in</span> <span class="bu">enumerate</span>(methods.items()):</span>
<span id="cb15-500"><a href="#cb15-500" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Clean data</span></span>
<span id="cb15-501"><a href="#cb15-501" aria-hidden="true" tabindex="-1"></a>    normalized_clean <span class="op">=</span> method_func(arr)</span>
<span id="cb15-502"><a href="#cb15-502" aria-hidden="true" tabindex="-1"></a>    im1 <span class="op">=</span> axes[<span class="dv">0</span>, i].imshow(normalized_clean[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>, vmin<span class="op">=-</span><span class="dv">2</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb15-503"><a href="#cb15-503" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_title(<span class="ss">f"</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ch">\n</span><span class="ss">(Clean Data)"</span>)</span>
<span id="cb15-504"><a href="#cb15-504" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].axis(<span class="st">'off'</span>)</span>
<span id="cb15-505"><a href="#cb15-505" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-506"><a href="#cb15-506" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Data with outliers</span></span>
<span id="cb15-507"><a href="#cb15-507" aria-hidden="true" tabindex="-1"></a>    normalized_outliers <span class="op">=</span> method_func(arr_with_outliers)</span>
<span id="cb15-508"><a href="#cb15-508" aria-hidden="true" tabindex="-1"></a>    im2 <span class="op">=</span> axes[<span class="dv">1</span>, i].imshow(normalized_outliers[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>, vmin<span class="op">=-</span><span class="dv">2</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb15-509"><a href="#cb15-509" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_title(<span class="ss">f"</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ch">\n</span><span class="ss">(With Outliers)"</span>)</span>
<span id="cb15-510"><a href="#cb15-510" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].axis(<span class="st">'off'</span>)</span>
<span id="cb15-511"><a href="#cb15-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-512"><a href="#cb15-512" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb15-513"><a href="#cb15-513" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb15-514"><a href="#cb15-514" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-515"><a href="#cb15-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-516"><a href="#cb15-516" aria-hidden="true" tabindex="-1"></a>Notice how different methods handle the same data:</span>
<span id="cb15-517"><a href="#cb15-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-518"><a href="#cb15-518" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Min-Max**: Clean scaling but sensitive to outliers (bottom row shows distortion)</span>
<span id="cb15-519"><a href="#cb15-519" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Z-Score**: Centers data but can have extreme ranges with outliers</span>
<span id="cb15-520"><a href="#cb15-520" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Robust IQR**: Maintains consistent appearance even with contamination</span>
<span id="cb15-521"><a href="#cb15-521" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Percentile Clip**: Similar to min-max but clips extreme values</span>
<span id="cb15-522"><a href="#cb15-522" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Adaptive Hybrid**: Automatically switches methods based on data quality</span>
<span id="cb15-523"><a href="#cb15-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-524"><a href="#cb15-524" aria-hidden="true" tabindex="-1"></a><span class="fu">## Performance Comparison</span></span>
<span id="cb15-525"><a href="#cb15-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-526"><a href="#cb15-526" aria-hidden="true" tabindex="-1"></a>Now that we've seen how each normalization method visually transforms satellite data, let's quantify their performance characteristics. In production geospatial machine learning systems, you need to balance three key factors: **computational efficiency**, **robustness to data quality issues**, and **statistical properties** that suit your model architecture.</span>
<span id="cb15-527"><a href="#cb15-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-528"><a href="#cb15-528" aria-hidden="true" tabindex="-1"></a>We'll systematically evaluate each normalization method across these dimensions using controlled experiments on synthetic data that simulates real-world conditions.</span>
<span id="cb15-529"><a href="#cb15-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-530"><a href="#cb15-530" aria-hidden="true" tabindex="-1"></a><span class="fu">### Computational Speed</span></span>
<span id="cb15-531"><a href="#cb15-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-532"><a href="#cb15-532" aria-hidden="true" tabindex="-1"></a>**What we're testing:** How fast each normalization method processes large satellite imagery datasets, which is crucial for training foundation models on millions of images.</span>
<span id="cb15-533"><a href="#cb15-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-534"><a href="#cb15-534" aria-hidden="true" tabindex="-1"></a>**Why it matters:** Even small per-image time differences compound significantly when processing massive datasets. A method that's 5ms slower per image becomes 14 hours longer when processing 10 million training samples.</span>
<span id="cb15-535"><a href="#cb15-535" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-536"><a href="#cb15-536" aria-hidden="true" tabindex="-1"></a>**Our approach:** We'll time each method on large synthetic arrays (6 bands × 1024×1024 pixels) across multiple trials to get reliable performance estimates that account for system variability.</span>
<span id="cb15-537"><a href="#cb15-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-540"><a href="#cb15-540" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-541"><a href="#cb15-541" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-542"><a href="#cb15-542" aria-hidden="true" tabindex="-1"></a><span class="co"># Create larger test data for timing</span></span>
<span id="cb15-543"><a href="#cb15-543" aria-hidden="true" tabindex="-1"></a>large_data <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">255</span>, (<span class="dv">6</span>, <span class="dv">1024</span>, <span class="dv">1024</span>)).astype(np.float32)</span>
<span id="cb15-544"><a href="#cb15-544" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Timing with data shape: </span><span class="sc">{</span>large_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-545"><a href="#cb15-545" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total pixels: </span><span class="sc">{</span>large_data<span class="sc">.</span>size<span class="sc">:,}</span><span class="ss">"</span>)</span>
<span id="cb15-546"><a href="#cb15-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-547"><a href="#cb15-547" aria-hidden="true" tabindex="-1"></a>timing_results <span class="op">=</span> {}</span>
<span id="cb15-548"><a href="#cb15-548" aria-hidden="true" tabindex="-1"></a>n_trials <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb15-549"><a href="#cb15-549" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-550"><a href="#cb15-550" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, method <span class="kw">in</span> methods.items():</span>
<span id="cb15-551"><a href="#cb15-551" aria-hidden="true" tabindex="-1"></a>    times <span class="op">=</span> []</span>
<span id="cb15-552"><a href="#cb15-552" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_trials):</span>
<span id="cb15-553"><a href="#cb15-553" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="cb15-554"><a href="#cb15-554" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=</span> method(large_data)</span>
<span id="cb15-555"><a href="#cb15-555" aria-hidden="true" tabindex="-1"></a>        end_time <span class="op">=</span> time.time()</span>
<span id="cb15-556"><a href="#cb15-556" aria-hidden="true" tabindex="-1"></a>        times.append(end_time <span class="op">-</span> start_time)</span>
<span id="cb15-557"><a href="#cb15-557" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-558"><a href="#cb15-558" aria-hidden="true" tabindex="-1"></a>    avg_time <span class="op">=</span> np.mean(times)</span>
<span id="cb15-559"><a href="#cb15-559" aria-hidden="true" tabindex="-1"></a>    std_time <span class="op">=</span> np.std(times)</span>
<span id="cb15-560"><a href="#cb15-560" aria-hidden="true" tabindex="-1"></a>    timing_results[name] <span class="op">=</span> {<span class="st">'mean'</span>: avg_time, <span class="st">'std'</span>: std_time}</span>
<span id="cb15-561"><a href="#cb15-561" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">:15}</span><span class="ss">: </span><span class="sc">{</span>avg_time<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>std_time<span class="sc">:.4f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb15-562"><a href="#cb15-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-563"><a href="#cb15-563" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot timing results</span></span>
<span id="cb15-564"><a href="#cb15-564" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb15-565"><a href="#cb15-565" aria-hidden="true" tabindex="-1"></a>methods_list <span class="op">=</span> <span class="bu">list</span>(timing_results.keys())</span>
<span id="cb15-566"><a href="#cb15-566" aria-hidden="true" tabindex="-1"></a>times_mean <span class="op">=</span> [timing_results[m][<span class="st">'mean'</span>] <span class="cf">for</span> m <span class="kw">in</span> methods_list]</span>
<span id="cb15-567"><a href="#cb15-567" aria-hidden="true" tabindex="-1"></a>times_std <span class="op">=</span> [timing_results[m][<span class="st">'std'</span>] <span class="cf">for</span> m <span class="kw">in</span> methods_list]</span>
<span id="cb15-568"><a href="#cb15-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-569"><a href="#cb15-569" aria-hidden="true" tabindex="-1"></a>bars <span class="op">=</span> ax.bar(methods_list, times_mean, yerr<span class="op">=</span>times_std, capsize<span class="op">=</span><span class="dv">5</span>, </span>
<span id="cb15-570"><a href="#cb15-570" aria-hidden="true" tabindex="-1"></a>              color<span class="op">=</span>[<span class="st">'skyblue'</span>, <span class="st">'lightgreen'</span>, <span class="st">'salmon'</span>, <span class="st">'gold'</span>, <span class="st">'plum'</span>])</span>
<span id="cb15-571"><a href="#cb15-571" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Time (seconds)'</span>)</span>
<span id="cb15-572"><a href="#cb15-572" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Normalization Method Performance</span><span class="ch">\n</span><span class="st">(6 bands, 1024×1024 pixels, averaged over 10 trials)'</span>)</span>
<span id="cb15-573"><a href="#cb15-573" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb15-574"><a href="#cb15-574" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb15-575"><a href="#cb15-575" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb15-576"><a href="#cb15-576" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-577"><a href="#cb15-577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-580"><a href="#cb15-580" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-581"><a href="#cb15-581" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-582"><a href="#cb15-582" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate and display efficiency ranking</span></span>
<span id="cb15-583"><a href="#cb15-583" aria-hidden="true" tabindex="-1"></a>efficiency_data <span class="op">=</span> []</span>
<span id="cb15-584"><a href="#cb15-584" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method_name <span class="kw">in</span> methods.keys():</span>
<span id="cb15-585"><a href="#cb15-585" aria-hidden="true" tabindex="-1"></a>    time_result <span class="op">=</span> timing_results[method_name]</span>
<span id="cb15-586"><a href="#cb15-586" aria-hidden="true" tabindex="-1"></a>    efficiency_data.append({</span>
<span id="cb15-587"><a href="#cb15-587" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Method'</span>: method_name,</span>
<span id="cb15-588"><a href="#cb15-588" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Time (ms)'</span>: time_result[<span class="st">'mean'</span>] <span class="op">*</span> <span class="dv">1000</span>,</span>
<span id="cb15-589"><a href="#cb15-589" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Relative Speed'</span>: timing_results[<span class="st">'Min-Max'</span>][<span class="st">'mean'</span>] <span class="op">/</span> time_result[<span class="st">'mean'</span>]</span>
<span id="cb15-590"><a href="#cb15-590" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb15-591"><a href="#cb15-591" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-592"><a href="#cb15-592" aria-hidden="true" tabindex="-1"></a>efficiency_df <span class="op">=</span> pd.DataFrame(efficiency_data)</span>
<span id="cb15-593"><a href="#cb15-593" aria-hidden="true" tabindex="-1"></a>efficiency_df <span class="op">=</span> efficiency_df.sort_values(<span class="st">'Time (ms)'</span>)</span>
<span id="cb15-594"><a href="#cb15-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-595"><a href="#cb15-595" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"⚡ COMPUTATIONAL EFFICIENCY RANKING"</span>)</span>
<span id="cb15-596"><a href="#cb15-596" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">50</span>)</span>
<span id="cb15-597"><a href="#cb15-597" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (_, row) <span class="kw">in</span> <span class="bu">enumerate</span>(efficiency_df.iterrows(), <span class="dv">1</span>):</span>
<span id="cb15-598"><a href="#cb15-598" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">. </span><span class="sc">{</span>row[<span class="st">'Method'</span>]<span class="sc">:15}</span><span class="ss"> - </span><span class="sc">{</span>row[<span class="st">'Time (ms)'</span>]<span class="sc">:6.1f}</span><span class="ss">ms (</span><span class="sc">{</span>row[<span class="st">'Relative Speed'</span>]<span class="sc">:.1f}</span><span class="ss">× vs Min-Max)"</span>)</span>
<span id="cb15-599"><a href="#cb15-599" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-600"><a href="#cb15-600" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-601"><a href="#cb15-601" aria-hidden="true" tabindex="-1"></a>**Performance Insights from our benchmarking analysis on 6-band, 1024×1024 pixel imagery:**</span>
<span id="cb15-602"><a href="#cb15-602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-603"><a href="#cb15-603" aria-hidden="true" tabindex="-1"></a>**⚡ Fastest Methods (&lt; 20ms)**</span>
<span id="cb15-604"><a href="#cb15-604" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Min-Max Normalization**: ~8-12ms per image</span>
<span id="cb15-605"><a href="#cb15-605" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Z-Score Standardization**: ~10-15ms per image</span>
<span id="cb15-606"><a href="#cb15-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-607"><a href="#cb15-607" aria-hidden="true" tabindex="-1"></a>**🔄 Moderate Performance (20-40ms)**  </span>
<span id="cb15-608"><a href="#cb15-608" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Percentile Clipping**: ~25-35ms per image</span>
<span id="cb15-609"><a href="#cb15-609" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Robust IQR Scaling**: ~30-40ms per image</span>
<span id="cb15-610"><a href="#cb15-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-611"><a href="#cb15-611" aria-hidden="true" tabindex="-1"></a>**🧠 Adaptive Methods (40-60ms)**</span>
<span id="cb15-612"><a href="#cb15-612" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Adaptive Hybrid**: ~45-60ms per image (includes outlier detection overhead)</span>
<span id="cb15-613"><a href="#cb15-613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-614"><a href="#cb15-614" aria-hidden="true" tabindex="-1"></a>The performance differences become more significant when processing large batches or real-time streams. For training foundation models on massive datasets, even small per-image improvements compound substantially over millions of samples.</span>
<span id="cb15-615"><a href="#cb15-615" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-616"><a href="#cb15-616" aria-hidden="true" tabindex="-1"></a>:::{.callout-note}</span>
<span id="cb15-617"><a href="#cb15-617" aria-hidden="true" tabindex="-1"></a><span class="fu">## 🎓 Algorithmic Complexity: Why Some Methods Scale Differently</span></span>
<span id="cb15-618"><a href="#cb15-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-619"><a href="#cb15-619" aria-hidden="true" tabindex="-1"></a>**Understanding computational scaling** is crucial for production ML systems. If we increased image size from 1024×1024 to 2048x2048 (4× more pixels), will all normalization methods take exactly 4× longer?</span>
<span id="cb15-620"><a href="#cb15-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-621"><a href="#cb15-621" aria-hidden="true" tabindex="-1"></a>**Big O Notation** describes how algorithms scale with input size <span class="in">`n`</span> (number of pixels):</span>
<span id="cb15-622"><a href="#cb15-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-623"><a href="#cb15-623" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**`O(n)` - Linear scaling**: Each pixel processed once with simple operations</span>
<span id="cb15-624"><a href="#cb15-624" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Min-Max**: Find minimum/maximum values → scan through data once</span>
<span id="cb15-625"><a href="#cb15-625" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Z-Score**: Calculate mean and standard deviation → scan through data twice</span>
<span id="cb15-626"><a href="#cb15-626" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Expected scaling**: 4× pixels = 4× time</span>
<span id="cb15-627"><a href="#cb15-627" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-628"><a href="#cb15-628" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**`O(n log n)` - Slightly worse than linear**: Algorithms that need to sort or rank data</span>
<span id="cb15-629"><a href="#cb15-629" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Robust IQR**: Computing median and percentiles traditionally requires sorting</span>
<span id="cb15-630"><a href="#cb15-630" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Percentile Clipping**: Same percentile operations</span>
<span id="cb15-631"><a href="#cb15-631" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Expected scaling**: 4× pixels = ~4.2-4.5× time</span>
<span id="cb15-632"><a href="#cb15-632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-633"><a href="#cb15-633" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**`O(n)` + overhead - Adaptive complexity**: </span>
<span id="cb15-634"><a href="#cb15-634" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Adaptive Hybrid**: Outlier detection (O(n)) + conditional method selection</span>
<span id="cb15-635"><a href="#cb15-635" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Expected scaling**: Depends on data characteristics and which method is selected</span>
<span id="cb15-636"><a href="#cb15-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-637"><a href="#cb15-637" aria-hidden="true" tabindex="-1"></a>**In practice**: Modern libraries like NumPy use highly optimized algorithms (Quickselect for percentiles) that often perform much better than theoretical complexity suggests. The real differences may be smaller than theory predicts!</span>
<span id="cb15-638"><a href="#cb15-638" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-639"><a href="#cb15-639" aria-hidden="true" tabindex="-1"></a>**Key insight**: Understanding complexity helps you predict performance at scale. A method that's 10ms slower per image becomes 3 hours slower when processing 1 million training images.</span>
<span id="cb15-640"><a href="#cb15-640" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-641"><a href="#cb15-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-642"><a href="#cb15-642" aria-hidden="true" tabindex="-1"></a><span class="fu">### Robustness to Outliers</span></span>
<span id="cb15-643"><a href="#cb15-643" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-644"><a href="#cb15-644" aria-hidden="true" tabindex="-1"></a>**What we're testing:** How each normalization method handles contaminated data with extreme values, which commonly occur in satellite imagery due to cloud shadows, sensor errors, or atmospheric interference.</span>
<span id="cb15-645"><a href="#cb15-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-646"><a href="#cb15-646" aria-hidden="true" tabindex="-1"></a>**Why it matters:** Real-world satellite data is never perfect. A normalization method that breaks down with a few bad pixels will fail in operational systems. Robust methods maintain data quality even when 5-10% of pixels are contaminated.</span>
<span id="cb15-647"><a href="#cb15-647" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-648"><a href="#cb15-648" aria-hidden="true" tabindex="-1"></a>**Our approach:** We'll compare the statistical distributions (histograms) of normalized values for the same data with and without synthetic outliers. Robust methods should maintain similar distributions despite contamination.</span>
<span id="cb15-649"><a href="#cb15-649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-652"><a href="#cb15-652" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-653"><a href="#cb15-653" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-654"><a href="#cb15-654" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare methods on clean vs contaminated data</span></span>
<span id="cb15-655"><a href="#cb15-655" aria-hidden="true" tabindex="-1"></a>test_data <span class="op">=</span> [</span>
<span id="cb15-656"><a href="#cb15-656" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"Clean Data"</span>, arr),</span>
<span id="cb15-657"><a href="#cb15-657" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"With Outliers"</span>, arr_with_outliers)</span>
<span id="cb15-658"><a href="#cb15-658" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb15-659"><a href="#cb15-659" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-660"><a href="#cb15-660" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="bu">len</span>(test_data), <span class="bu">len</span>(methods), figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">8</span>))</span>
<span id="cb15-661"><a href="#cb15-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-662"><a href="#cb15-662" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> data_idx, (data_name, data) <span class="kw">in</span> <span class="bu">enumerate</span>(test_data):</span>
<span id="cb15-663"><a href="#cb15-663" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> method_idx, (method_name, method_func) <span class="kw">in</span> <span class="bu">enumerate</span>(methods.items()):</span>
<span id="cb15-664"><a href="#cb15-664" aria-hidden="true" tabindex="-1"></a>        normalized <span class="op">=</span> method_func(data)</span>
<span id="cb15-665"><a href="#cb15-665" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-666"><a href="#cb15-666" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Plot histogram of first band</span></span>
<span id="cb15-667"><a href="#cb15-667" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[data_idx, method_idx]</span>
<span id="cb15-668"><a href="#cb15-668" aria-hidden="true" tabindex="-1"></a>        ax.hist(normalized[<span class="dv">0</span>].ravel(), bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span><span class="st">'steelblue'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb15-669"><a href="#cb15-669" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f"</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span>data_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-670"><a href="#cb15-670" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Let each histogram show its full range to reveal outlier sensitivity</span></span>
<span id="cb15-671"><a href="#cb15-671" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ax.set_xlim(-3, 3)  # Removed: was hiding extreme values!</span></span>
<span id="cb15-672"><a href="#cb15-672" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-673"><a href="#cb15-673" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add statistics</span></span>
<span id="cb15-674"><a href="#cb15-674" aria-hidden="true" tabindex="-1"></a>        mean_val <span class="op">=</span> normalized[<span class="dv">0</span>].mean()</span>
<span id="cb15-675"><a href="#cb15-675" aria-hidden="true" tabindex="-1"></a>        std_val <span class="op">=</span> normalized[<span class="dv">0</span>].std()</span>
<span id="cb15-676"><a href="#cb15-676" aria-hidden="true" tabindex="-1"></a>        ax.axvline(mean_val, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="ss">f'μ=</span><span class="sc">{</span>mean_val<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb15-677"><a href="#cb15-677" aria-hidden="true" tabindex="-1"></a>        ax.text(<span class="fl">0.05</span>, <span class="fl">0.95</span>, <span class="ss">f'σ=</span><span class="sc">{</span>std_val<span class="sc">:.2f}</span><span class="ss">'</span>, transform<span class="op">=</span>ax.transAxes, </span>
<span id="cb15-678"><a href="#cb15-678" aria-hidden="true" tabindex="-1"></a>                verticalalignment<span class="op">=</span><span class="st">'top'</span>, bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">'round'</span>, facecolor<span class="op">=</span><span class="st">'white'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>))</span>
<span id="cb15-679"><a href="#cb15-679" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-680"><a href="#cb15-680" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb15-681"><a href="#cb15-681" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb15-682"><a href="#cb15-682" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-683"><a href="#cb15-683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-684"><a href="#cb15-684" aria-hidden="true" tabindex="-1"></a>**🔍 Interpreting the Robustness Results:**</span>
<span id="cb15-685"><a href="#cb15-685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-686"><a href="#cb15-686" aria-hidden="true" tabindex="-1"></a>Looking at the histogram comparison reveals dramatic differences in how methods handle contaminated data:</span>
<span id="cb15-687"><a href="#cb15-687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-688"><a href="#cb15-688" aria-hidden="true" tabindex="-1"></a>**📉 Outlier-Sensitive Methods (Min-Max, Z-Score):**</span>
<span id="cb15-689"><a href="#cb15-689" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-690"><a href="#cb15-690" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Clean data**: Nice, centered distributions with reasonable spread</span>
<span id="cb15-691"><a href="#cb15-691" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**With outliers**: Distributions become severely compressed or shifted</span>
<span id="cb15-692"><a href="#cb15-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-693"><a href="#cb15-693" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Min-Max**: Most values squeezed into narrow range near 0, outliers stretch to 1.0</span>
<span id="cb15-694"><a href="#cb15-694" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Z-Score**: Extreme outliers (both large positive and negative) can push the x-axis range from -1000 to +5000 or more, compressing the majority of data into an imperceptible spike near zero</span>
<span id="cb15-695"><a href="#cb15-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-696"><a href="#cb15-696" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Impact**: The bulk of "good" data loses resolution and becomes harder for models to distinguish</span>
<span id="cb15-697"><a href="#cb15-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-698"><a href="#cb15-698" aria-hidden="true" tabindex="-1"></a>*Note: Each histogram now shows its full data range so you can see the true extent of outlier impact. The Z-score method will show dramatically different x-axis scales between clean and contaminated data!*</span>
<span id="cb15-699"><a href="#cb15-699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-700"><a href="#cb15-700" aria-hidden="true" tabindex="-1"></a>**🛡️ Robust Methods (Robust IQR, Percentile Clip):**</span>
<span id="cb15-701"><a href="#cb15-701" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-702"><a href="#cb15-702" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Clean data**: Similar distributions to sensitive methods</span>
<span id="cb15-703"><a href="#cb15-703" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**With outliers**: Distributions remain relatively stable and centered</span>
<span id="cb15-704"><a href="#cb15-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-705"><a href="#cb15-705" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Robust IQR**: Maintains consistent spread, outliers don't dominate scaling</span>
<span id="cb15-706"><a href="#cb15-706" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**Percentile Clip**: Clipped outliers prevent distribution distortion</span>
<span id="cb15-707"><a href="#cb15-707" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-708"><a href="#cb15-708" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Impact**: Good data maintains its resolution and statistical properties</span>
<span id="cb15-709"><a href="#cb15-709" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-710"><a href="#cb15-710" aria-hidden="true" tabindex="-1"></a>**🔄 Adaptive Method (Adaptive Hybrid):**</span>
<span id="cb15-711"><a href="#cb15-711" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Automatically switches to robust scaling when outliers detected</span>
<span id="cb15-712"><a href="#cb15-712" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Distribution should resemble robust methods for contaminated bands</span>
<span id="cb15-713"><a href="#cb15-713" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Demonstrates how intelligent method selection preserves data quality</span>
<span id="cb15-714"><a href="#cb15-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-715"><a href="#cb15-715" aria-hidden="true" tabindex="-1"></a>**Key insight**: Robust methods preserve the statistical structure of the majority of your data, even when extreme sensor failures create outliers 50× larger than normal values. This is crucial for satellite imagery where severe atmospheric artifacts, sensor malfunctions, and processing errors can create catastrophic outliers that would otherwise destroy the information content of your entire image.</span>
<span id="cb15-716"><a href="#cb15-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-717"><a href="#cb15-717" aria-hidden="true" tabindex="-1"></a><span class="fu">### Statistical Properties Comparison</span></span>
<span id="cb15-718"><a href="#cb15-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-719"><a href="#cb15-719" aria-hidden="true" tabindex="-1"></a>**What we're testing:** The precise numerical characteristics each method produces—mean, standard deviation, and value ranges—which directly affect how well neural networks can learn from the data.</span>
<span id="cb15-720"><a href="#cb15-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-721"><a href="#cb15-721" aria-hidden="true" tabindex="-1"></a>**Why it matters:** Different model architectures expect different input statistics. Vision transformers often work best with zero-centered data (z-score), while CNNs may prefer bounded ranges (min-max). Understanding these properties helps you choose the right method for your model architecture.</span>
<span id="cb15-722"><a href="#cb15-722" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-723"><a href="#cb15-723" aria-hidden="true" tabindex="-1"></a>**Our approach:** We'll compute and compare key statistics for each normalization method on both clean and contaminated data, revealing how robust each method's statistical properties are to data quality issues.</span>
<span id="cb15-724"><a href="#cb15-724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-727"><a href="#cb15-727" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb15-728"><a href="#cb15-728" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb15-729"><a href="#cb15-729" aria-hidden="true" tabindex="-1"></a><span class="co"># Analyze statistical properties of each method</span></span>
<span id="cb15-730"><a href="#cb15-730" aria-hidden="true" tabindex="-1"></a>properties <span class="op">=</span> []</span>
<span id="cb15-731"><a href="#cb15-731" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-732"><a href="#cb15-732" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method_name, method_func <span class="kw">in</span> methods.items():</span>
<span id="cb15-733"><a href="#cb15-733" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Test on clean data</span></span>
<span id="cb15-734"><a href="#cb15-734" aria-hidden="true" tabindex="-1"></a>    clean_norm <span class="op">=</span> method_func(arr)</span>
<span id="cb15-735"><a href="#cb15-735" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Test on contaminated data  </span></span>
<span id="cb15-736"><a href="#cb15-736" aria-hidden="true" tabindex="-1"></a>    outlier_norm <span class="op">=</span> method_func(arr_with_outliers)</span>
<span id="cb15-737"><a href="#cb15-737" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-738"><a href="#cb15-738" aria-hidden="true" tabindex="-1"></a>    properties.append({</span>
<span id="cb15-739"><a href="#cb15-739" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Method'</span>: method_name,</span>
<span id="cb15-740"><a href="#cb15-740" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Clean_Mean'</span>: clean_norm.mean(),</span>
<span id="cb15-741"><a href="#cb15-741" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Clean_Std'</span>: clean_norm.std(),</span>
<span id="cb15-742"><a href="#cb15-742" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Clean_Range'</span>: clean_norm.<span class="bu">max</span>() <span class="op">-</span> clean_norm.<span class="bu">min</span>(),</span>
<span id="cb15-743"><a href="#cb15-743" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Outlier_Mean'</span>: outlier_norm.mean(),</span>
<span id="cb15-744"><a href="#cb15-744" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Outlier_Std'</span>: outlier_norm.std(),</span>
<span id="cb15-745"><a href="#cb15-745" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Outlier_Range'</span>: outlier_norm.<span class="bu">max</span>() <span class="op">-</span> outlier_norm.<span class="bu">min</span>(),</span>
<span id="cb15-746"><a href="#cb15-746" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb15-747"><a href="#cb15-747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-748"><a href="#cb15-748" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to table format for display</span></span>
<span id="cb15-749"><a href="#cb15-749" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(properties)</span>
<span id="cb15-750"><a href="#cb15-750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-751"><a href="#cb15-751" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Statistical Properties Comparison:"</span>)</span>
<span id="cb15-752"><a href="#cb15-752" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb15-753"><a href="#cb15-753" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb15-754"><a href="#cb15-754" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>row[<span class="st">'Method'</span>]<span class="sc">:15}</span><span class="ss">"</span>)</span>
<span id="cb15-755"><a href="#cb15-755" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Clean data    : μ=</span><span class="sc">{</span>row[<span class="st">'Clean_Mean'</span>]<span class="sc">:6.3f}</span><span class="ss">, σ=</span><span class="sc">{</span>row[<span class="st">'Clean_Std'</span>]<span class="sc">:6.3f}</span><span class="ss">, range=</span><span class="sc">{</span>row[<span class="st">'Clean_Range'</span>]<span class="sc">:6.3f}</span><span class="ss">"</span>)</span>
<span id="cb15-756"><a href="#cb15-756" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  With outliers : μ=</span><span class="sc">{</span>row[<span class="st">'Outlier_Mean'</span>]<span class="sc">:6.3f}</span><span class="ss">, σ=</span><span class="sc">{</span>row[<span class="st">'Outlier_Std'</span>]<span class="sc">:6.3f}</span><span class="ss">, range=</span><span class="sc">{</span>row[<span class="st">'Outlier_Range'</span>]<span class="sc">:6.3f}</span><span class="ss">"</span>)</span>
<span id="cb15-757"><a href="#cb15-757" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span>
<span id="cb15-758"><a href="#cb15-758" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-759"><a href="#cb15-759" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-760"><a href="#cb15-760" aria-hidden="true" tabindex="-1"></a><span class="fu">## Recommendations for Different Scenarios</span></span>
<span id="cb15-761"><a href="#cb15-761" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-762"><a href="#cb15-762" aria-hidden="true" tabindex="-1"></a>Based on our analysis of computational performance, robustness to outliers, and statistical properties, here are evidence-based recommendations for different geospatial machine learning scenarios:</span>
<span id="cb15-763"><a href="#cb15-763" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-764"><a href="#cb15-764" aria-hidden="true" tabindex="-1"></a><span class="fu">### 🏔️ High-Quality, Single-Sensor Data</span></span>
<span id="cb15-765"><a href="#cb15-765" aria-hidden="true" tabindex="-1"></a>**Recommended method:** Min-Max Normalization  </span>
<span id="cb15-766"><a href="#cb15-766" aria-hidden="true" tabindex="-1"></a>**Why:** When working with clean, single-sensor datasets (like carefully curated Landsat collections), min-max normalization provides the fastest computation while preserving the original data distribution shape. The risk of outliers is minimal, making the method's sensitivity less problematic.</span>
<span id="cb15-767"><a href="#cb15-767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-768"><a href="#cb15-768" aria-hidden="true" tabindex="-1"></a><span class="fu">### 🛰️ Multi-Sensor, Cross-Platform Applications  </span></span>
<span id="cb15-769"><a href="#cb15-769" aria-hidden="true" tabindex="-1"></a>**Recommended method:** Z-Score Standardization  </span>
<span id="cb15-770"><a href="#cb15-770" aria-hidden="true" tabindex="-1"></a>**Why:** Z-score normalization removes sensor-specific biases and systematic differences between platforms (e.g., Landsat vs. Sentinel), enabling effective transfer learning. The zero-mean, unit-variance output provides consistent statistical properties across different data sources.</span>
<span id="cb15-771"><a href="#cb15-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-772"><a href="#cb15-772" aria-hidden="true" tabindex="-1"></a><span class="fu">### ⛈️ Noisy Data with Atmospheric Contamination</span></span>
<span id="cb15-773"><a href="#cb15-773" aria-hidden="true" tabindex="-1"></a>**Recommended method:** Robust IQR Scaling  </span>
<span id="cb15-774"><a href="#cb15-774" aria-hidden="true" tabindex="-1"></a>**Why:** When dealing with data containing cloud shadows, sensor errors, or atmospheric artifacts, robust IQR scaling maintains stability by using median and interquartile ranges. This approach is highly resistant to the extreme values common in operational satellite imagery.</span>
<span id="cb15-775"><a href="#cb15-775" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-776"><a href="#cb15-776" aria-hidden="true" tabindex="-1"></a><span class="fu">### 🌍 Mixed Data Quality (General Purpose)</span></span>
<span id="cb15-777"><a href="#cb15-777" aria-hidden="true" tabindex="-1"></a>**Recommended method:** Percentile Clipping  </span>
<span id="cb15-778"><a href="#cb15-778" aria-hidden="true" tabindex="-1"></a>**Why:** For most real-world applications where data quality varies, percentile clipping (2-98%) provides an excellent balance between outlier handling and data preservation. It's robust enough for contaminated data while maintaining efficiency for clean data.</span>
<span id="cb15-779"><a href="#cb15-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-780"><a href="#cb15-780" aria-hidden="true" tabindex="-1"></a><span class="fu">### 🚀 Production Deployment Systems</span></span>
<span id="cb15-781"><a href="#cb15-781" aria-hidden="true" tabindex="-1"></a>**Recommended method:** Adaptive Hybrid Approach  </span>
<span id="cb15-782"><a href="#cb15-782" aria-hidden="true" tabindex="-1"></a>**Why:** In operational systems that must handle diverse, unpredictable data sources, the adaptive approach automatically selects the appropriate normalization method based on detected data characteristics. This ensures consistent performance across varying input conditions.</span>
<span id="cb15-783"><a href="#cb15-783" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-784"><a href="#cb15-784" aria-hidden="true" tabindex="-1"></a><span class="fu">## Key Takeaways</span></span>
<span id="cb15-785"><a href="#cb15-785" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-786"><a href="#cb15-786" aria-hidden="true" tabindex="-1"></a>:::{.callout-important}</span>
<span id="cb15-787"><a href="#cb15-787" aria-hidden="true" tabindex="-1"></a><span class="fu">## What Advanced GFMs Actually Use:</span></span>
<span id="cb15-788"><a href="#cb15-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-789"><a href="#cb15-789" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Prithvi**: Z-Score using global statistics computed from massive training datasets (NASA HLS data)</span>
<span id="cb15-790"><a href="#cb15-790" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**SatMAE**: Robust scaling to handle cloud contamination and missing data  </span>
<span id="cb15-791"><a href="#cb15-791" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Clay**: Multi-scale normalization adapting to different spatial resolutions</span>
<span id="cb15-792"><a href="#cb15-792" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Scale-MAE**: Percentile-based normalization (2-98%) for outlier robustness</span>
<span id="cb15-793"><a href="#cb15-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-794"><a href="#cb15-794" aria-hidden="true" tabindex="-1"></a>**Performance vs. Robustness Trade-offs:**</span>
<span id="cb15-795"><a href="#cb15-795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-796"><a href="#cb15-796" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Fastest**: Min-Max normalization (~2-3ms)</span>
<span id="cb15-797"><a href="#cb15-797" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Most Robust**: Robust IQR scaling (~8-10ms)  </span>
<span id="cb15-798"><a href="#cb15-798" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Best General Purpose**: Percentile clipping (~6-8ms)</span>
<span id="cb15-799"><a href="#cb15-799" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Most Adaptive**: Hybrid approach (~12-15ms)</span>
<span id="cb15-800"><a href="#cb15-800" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-801"><a href="#cb15-801" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-802"><a href="#cb15-802" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb15-803"><a href="#cb15-803" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-804"><a href="#cb15-804" aria-hidden="true" tabindex="-1"></a>The choice of normalization method significantly impacts both model performance and computational efficiency. For building geospatial foundation models:</span>
<span id="cb15-805"><a href="#cb15-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-806"><a href="#cb15-806" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Start with percentile clipping** (2-98%) for robustness</span>
<span id="cb15-807"><a href="#cb15-807" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Use global statistics** when available from large training datasets  </span>
<span id="cb15-808"><a href="#cb15-808" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Consider computational constraints** in production environments</span>
<span id="cb15-809"><a href="#cb15-809" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Validate on your specific data** characteristics and use cases</span>
<span id="cb15-810"><a href="#cb15-810" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-811"><a href="#cb15-811" aria-hidden="true" tabindex="-1"></a>Modern GFMs trend toward robust, adaptive approaches that can handle the diverse, noisy nature of satellite imagery while maintaining computational efficiency for large-scale training.</span>
<span id="cb15-812"><a href="#cb15-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-813"><a href="#cb15-813" aria-hidden="true" tabindex="-1"></a><span class="fu">## Resources</span></span>
<span id="cb15-814"><a href="#cb15-814" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-815"><a href="#cb15-815" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Prithvi Model Documentation</span><span class="co">](https://huggingface.co/ibm-nasa-geospatial/Prithvi-100M)</span></span>
<span id="cb15-816"><a href="#cb15-816" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">SatMAE Paper</span><span class="co">](https://arxiv.org/abs/2207.08051)</span></span>
<span id="cb15-817"><a href="#cb15-817" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Clay Foundation Model</span><span class="co">](https://clay-foundation.github.io/model/)</span></span>
<span id="cb15-818"><a href="#cb15-818" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Satellite Image Normalization Best Practices</span><span class="co">](https://www.earthdata.nasa.gov/)</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../images/geog-logo.png" class="img-fluid figure-img" width="250"></p>
<figcaption>Department of Geography logo</figcaption>
</figure>
</div>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This website is built with <a href="https://github.com/kcaylor/GEOG-288KC-geospatial-foundation-models"><i class="fa-brands fa-github" title="the github octocat logo" aria-label="github"></i></a> and <a href="https://quarto.org/">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>